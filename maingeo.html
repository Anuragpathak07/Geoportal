<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Geoportal</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üó∫Ô∏è</text></svg>" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <!-- Leaflet Draw CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />

  <!-- CesiumJS CSS and JS -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

  <!-- shapfe file support -->
  <!-- Replace the existing shp script with this: -->
  <script src="https://unpkg.com/shpjs@latest/dist/shp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.min.js"></script>

  <!-- Leaflet Control Geocoder (must come before Routing Machine) -->
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <!-- Leaflet Routing Machine -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Plotly.js for the chart -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

  <!-- Leaflet Draw for path drawing -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <!-- (Optional) Google Fonts for clean UI -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <script>
    // These will be set after fetching config
    let GEOSERVER_URL = null;
    let PROXY_URL = null;

    // Fetch config from the Flask endpoint
    function fetchNgrokConfig() {
      return fetch('ngrok_urls.json')
        .then(res => res.json())
        .then(cfg => {
          GEOSERVER_URL = cfg.geoserver_url;
          PROXY_URL = cfg.proxy_url;
          console.log('GeoServer:', GEOSERVER_URL, 'Proxy:', PROXY_URL);
        });
    }
  </script>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Function to check if shp library is loaded
      function checkShpLibrary() {
        if (typeof shp !== "undefined") {
          console.log("DOM loaded, shp available:", true);
          // Your initialization code here
        } else {
          console.log("Waiting for shp library to load...");
          setTimeout(checkShpLibrary, 100); // Check again after 100ms
        }
      }

      checkShpLibrary();
    });
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .leaflet-draw.leaflet-control {
      display: none !important;
    }

    body {
      font-family: "Georgia", serif;
      /* Classic, readable font */
      background: #fdf6e3;
      /* A warm, earthy base color */
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Navbar Styles */
    .navbar {
      background: #2e1a0e;
      border-bottom: 2px solid #3e2723;
      /* Darker border for depth */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      padding: 5px 16px;
      /* Reduced vertical padding */
      z-index: 1000;
      position: relative;
      min-height: 50px;
      /* Reduced height */
      width: 100%;
      overflow: visible;
    }

    /* Navbar Brand Styles */
    .navbar-brand {
      color: white;
      font-size: 20px;
      /* Reduced font size */
      font-weight: bold;
      margin-right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .navbar-brand i {
      font-size: 24px;
      /* Reduced icon size */
      color: #f5e8c7;
      /* Light gold color for the globe icon */
    }

    .navbar-content {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      position: relative;
      min-height: 44px;
      flex-wrap: wrap;
      padding: 0 8px;
      overflow: visible;
      justify-content: flex-start;
    }

    .navbar-group {
      display: flex;
      align-items: center;
      position: relative;
      margin: 0 4px;
    }

    /* Feature Button Styles */
    .feature-btn {
      width: 36px;
      /* Reduced button size */
      height: 36px;
      /* Reduced button size */
      border-radius: 50%;
      background: #c19a6b;
      /* Muted gold/brown for buttons */
      border: 1px solid #8a6c4a;
      color: #fff;
      /* White icons for contrast */
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      font-size: 16px;
      flex-shrink: 0;
    }

    .feature-btn>.fas:not(.fa-chevron-down) {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .feature-btn:hover {
      background: #a98457;
      /* Slightly darker on hover */
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .feature-btn.active {
      background: #8a6c4a;
      /* Darker, active state */
      color: white;
      border-color: #5c4831;
    }

    /* Tooltip Styles */
    .feature-btn::after {
      content: attr(title);
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      background: #483434;
      /* Dark brown tooltip background */
      color: #f5e8c7;
      /* Light text for readability */
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .feature-btn:hover::after {
      opacity: 1;
      visibility: visible;
    }

    /* Dropdown Arrow Styles */
    .feature-btn i.fa-chevron-down {
      position: absolute;
      bottom: 3px;
      /* Adjusted for better visual alignment */
      left: 50%;
      transform: translateX(-50%);
      font-size: 8px;
      color: #f5e8c7;
      /* Light color for the arrow */
    }

    .feature-btn.active i.fa-chevron-down {
      color: white;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .navbar {
        padding: 8px 12px;
      }

      .navbar-content {
        gap: 6px;
        justify-content: center;
      }

      .feature-btn {
        width: 36px;
        height: 36px;
        font-size: 14px;
      }

      .dropdown-content {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        max-width: 300px;
      }
    }

    /* Remove all overflow-related CSS */
    .navbar-content:not(.expanded)>.navbar-group.overflow-item,
    .navbar-content:not(.expanded)>.navbar-group:nth-child(n + 7) {
      display: flex !important;
    }

    /* Remove navbar toggle and overflow toggle styles */
    .navbar-toggle,
    .navbar-overflow-toggle,
    .navbar-overflow-toggle.hidden {
      display: none !important;
    }

    /* Ensure all navbar groups are visible */
    .navbar-group {
      display: flex !important;
      opacity: 1 !important;
      visibility: visible !important;
    }

    /* ADD THIS NEW RULE */
    .navbar-group:nth-last-child(-n + 3) .dropdown-content {
      right: 0;
      left: auto;
    }

    /* Dropdown Styles */
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #c19a6b;
      /* Matching the button color */
      min-width: 220px;
      max-width: 280px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      z-index: 9999;
      border-radius: 8px;
      padding: 8px;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
      top: calc(100% + 5px);
      left: 50%;
      transform: translateX(-50%);
    }

    .dropdown-content.show {
      display: block;
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Last 3 dropdowns should align to the right */
    .navbar-group:nth-last-child(-n + 3) .dropdown-content {
      left: auto;
      right: 0;
      transform: translateX(0) translateY(-10px);
    }

    .navbar-group:nth-last-child(-n + 3) .dropdown-content.show {
      transform: translateX(0) translateY(0);
    }

    .dropdown-section {
      padding: 6px 0;
    }

    .dropdown-section:not(:last-child) {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      margin-bottom: 6px;
      padding-bottom: 8px;
    }

    .dropdown-section h4 {
      color: #2c3e50;
      font-size: 13px;
      margin: 0 0 6px 0;
      padding: 0 8px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sub-btn {
      display: flex;
      align-items: center;
      width: 100%;
      padding: 6px 8px;
      border: none;
      background: none;
      color: #2c3e50;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      border-radius: 4px;
      text-align: left;
      white-space: nowrap;
    }

    .sub-btn:hover {
      background-color: rgba(52, 152, 219, 0.1);
      color: #3498db;
    }

    .sub-btn i {
      margin-right: 8px;
      width: 14px;
      text-align: center;
      color: #3498db;
      font-size: 12px;
    }

    /* Basemap Gallery in Dropdown */
    #basemaps-dropdown .basemap-gallery {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      padding: 12px;
      background: rgba(248, 249, 250, 0.5);
      border-radius: 8px;
      margin: 8px 0;
    }

    #basemaps-dropdown .basemap-item {
      aspect-ratio: 1;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
      min-height: 80px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    #basemaps-dropdown .basemap-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.4) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #basemaps-dropdown .basemap-item:hover {
      border-color: #007bff;
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 8px 16px rgba(0, 123, 255, 0.15);
    }

    #basemaps-dropdown .basemap-item:hover::before {
      opacity: 1;
    }

    #basemaps-dropdown .basemap-item.active {
      border-color: #007bff;
      box-shadow: 0 0 0 2px #007bff, 0 8px 16px rgba(0, 123, 255, 0.2);
    }

    #basemaps-dropdown .basemap-item.active::after {
      content: '‚úì';
      position: absolute;
      top: 8px;
      right: 8px;
      background: #007bff;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    #basemaps-dropdown .basemap-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px;
      font-size: 12px;
      text-align: center;
      backdrop-filter: blur(4px);
      transform: translateY(100%);
      transition: transform 0.3s ease;
      font-weight: 500;
    }

    #basemaps-dropdown .basemap-item:hover .basemap-label {
      transform: translateY(0);
    }

    #basemaps-dropdown .basemap-item.active .basemap-label {
      transform: translateY(0);
      background: rgba(0, 123, 255, 0.9);
    }

    /* Add preview images for basemaps */
    #basemaps-dropdown .basemap-item[data-basemap="osm"] {
      background-image: url('https://tile.openstreetmap.org/0/0/0.png');
    }

    #basemaps-dropdown .basemap-item[data-basemap="satellite"] {
      background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/0/0/0');
    }

    #basemaps-dropdown .basemap-item[data-basemap="terrain"] {
      background-image: url('https://tile.opentopomap.org/0/0/0.png');
    }

    #basemaps-dropdown .basemap-item[data-basemap="dark"] {
      background-image: url('https://basemaps.cartocdn.com/dark_all/0/0/0.png');
    }

    #basemaps-dropdown .basemap-item[data-basemap="esri_topo"] {
      background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/0/0/0');
    }

    #basemaps-dropdown .basemap-item[data-basemap="esri_ocean"] {
      background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/0/0/0');
    }

    #basemaps-dropdown .basemap-item[data-basemap="google_hybrid"] {
      background-image: url('https://mt1.google.com/vt/lyrs=y&x=0&y=0&z=0');
    }

    /* File Upload in Dropdown */
    .file-upload {
      border: 2px dashed rgba(52, 152, 219, 0.3);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background-color: rgba(52, 152, 219, 0.05);
    }

    .file-upload:hover {
      border-color: #3498db;
      background-color: rgba(52, 152, 219, 0.1);
    }

    .file-upload input[type="file"] {
      display: none;
    }

    /* Search Input */
    .search-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 13px;
      transition: all 0.3s ease;
    }

    .search-input:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }

    /* Layer Selector */
    .layer-selector {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 13px;
      transition: all 0.2s ease;
      background-color: white;
    }

    .layer-selector:focus {
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
      outline: none;
    }

    /* Legend Container */
    .legend-container {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      display: none;
    }

    .legend-container h4 {
      margin-bottom: 10px;
      font-size: 14px;
      color: #333;
    }

    .feature-btn i {
      margin-right: 10px;
      width: 20px;
      text-align: center;
    }

    .expand-icon {
      transition: transform 0.3s ease;
    }

    .expand-icon.rotated {
      transform: rotate(180deg);
    }

    /* Expandable Content */
    .expandable-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: rgba(248, 249, 250, 0.5);
      border-radius: 8px;
      margin-top: 5px;
    }

    .expandable-content.expanded {
      max-height: 500px;
      padding: 10px;
    }

    .sub-btn {
      width: 100%;
      padding: 8px 12px;
      background: white;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 5px;
      transition: all 0.2s ease;
      font-size: 13px;
      display: flex;
      align-items: center;
    }

    .sub-btn:hover {
      background: #f8f9fa;
      border-color: #007bff;
    }

    .sub-btn.active {
      background: #007bff;
      color: white;
      border-color: #0056b3;
    }

    .sub-btn i {
      margin-right: 8px;
      width: 16px;
      text-align: center;
    }

    /* Map Container */
    #map-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      min-height: 0;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    #cesiumContainer {
      height: 100%;
      width: 100%;
      display: none;
      /* Initially hidden */
    }

    /* Basemap Gallery */
    .basemap-gallery {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: 400px;
      overflow-y: auto;
    }

    .basemap-item {
      aspect-ratio: 1;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .basemap-item:hover {
      border-color: #007bff;
      transform: scale(1.05);
    }

    .basemap-item.active {
      border-color: #007bff;
      box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
    }

    .basemap-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      font-size: 11px;
      text-align: center;
    }

    /* Layer Control */
    .layer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      background: white;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      margin-bottom: 5px;
    }

    .layer-checkbox {
      margin-right: 10px;
    }

    .layer-name {
      flex: 1;
      font-size: 13px;
      min-width: 0;
      white-space: normal;
      /* Allow text to wrap */
      word-wrap: break-word;
      /* Break long words */
    }

    .layer-opacity {
      width: 60px;
      margin-left: 10px;
    }

    /* File Upload */
    .file-upload {
      border: 2px dashed #007bff;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      background: rgba(0, 123, 255, 0.05);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .file-upload:hover {
      background: rgba(0, 123, 255, 0.1);
      border-color: #0056b3;
      transform: translateY(-2px);
    }

    .file-upload input {
      display: none;
    }

    /* Coordinate Display */
    .coordinate-display {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 1000;
    }

    /* Custom Scrollbar */
    .sidebar-content::-webkit-scrollbar {
      width: 8px;
    }

    .sidebar-content::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 4px;
    }

    .sidebar-content::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }

    .sidebar-content::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.5);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .navbar {
        padding: 8px 12px;
        height: auto;
        min-height: 60px;
        flex-wrap: wrap;
      }

      .navbar-content {
        gap: 15px;
      }

      .feature-btn {
        font-size: 12px;
        padding: 6px 12px;
      }

      .dropdown-content {
        min-width: 250px;
        max-height: 50vh;
      }

      .basemap-gallery {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Additional CSS for Utility Tools */
    .dropdown-section {
      margin-bottom: 15px;
      padding-bottom: 10px;
    }

    .dropdown-section:not(:last-child) {
      border-bottom: 1px solid #e9ecef;
    }

    .dropdown-section h4 {
      margin: 0 0 10px 0;
      font-size: 12px;
      font-weight: 600;
      color: #495057;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sub-btn i {
      margin-right: 8px;
      width: 16px;
      text-align: center;
      color: #6c757d;
    }

    .sub-btn:hover i {
      color: #007bff;
    }

    /* Ensure dropdown content has proper spacing */
    .dropdown-content {
      min-width: 250px;
      max-height: 400px;
      overflow-y: auto;
      padding: 15px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .dropdown-content {
        min-width: 200px;
        max-height: 300px;
      }

      .dropdown-section h4 {
        font-size: 11px;
      }

      .sub-btn {
        font-size: 12px;
        padding: 6px 10px;
      }
    }

    /* Add these styles in the <style> section */
    .advanced-tools-dropdown {
      position: relative;
    }

    .advanced-tools-menu {
      position: absolute;
      top: 100%;
      left: 0;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 8px 0;
      min-width: 220px;
      display: none;
      z-index: 1002;
    }

    .advanced-tools-menu.show {
      display: block;
    }

    .advanced-tools-item {
      padding: 8px 16px;
      display: flex;
      align-items: center;
      color: #2c3e50;
      text-decoration: none;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .advanced-tools-item:hover {
      background: #f8f9fa;
      color: #3498db;
    }

    .advanced-tools-item i {
      margin-right: 8px;
      width: 16px;
      text-align: center;
    }

    .legend-control {
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border-radius: 3px;
    }

    .legend-label {
      font-size: 12px;
      color: #2c3e50;
    }

    /* WMS INFO PANEL STYLES (existing) */
    #wms-info-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 350px;
      max-width: 90vw;
      height: 100vh;
      z-index: 1000;
      transition: transform 0.3s ease-in-out;
      transform: translateX(100%);
      background: #fdf6e3;
      border-left: 2px solid #3e2723;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding-top: 60px;
      /* Adjust if your navbar is taller/shorter */
    }

    #feature-info-panel.visible {
      transform: translateX(0);
    }

    #feature-info-panel h4 {
      padding: 15px;
      background: #2e1a0e;
      color: white;
      margin: 0;
      font-size: 18px;
    }

    #feature-info-panel .close-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
    }

    #feature-list {
      padding: 15px;
      overflow-y: auto;
      flex-grow: 1;
      /* Allows the list to fill available space */
    }

    .feature-item {
      border-bottom: 1px solid #ddd;
      padding: 10px 0;
    }

    .feature-item:last-child {
      border-bottom: none;
    }

    .feature-item b {
      color: #483434;
    }

    .info-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      width: 30vw;
      max-width: 400px;
      min-width: 260px;
      background: #fff;
      box-shadow: -2px 0 16px rgba(0, 0, 0, 0.15);
      transform: translateX(100%);
      transition: transform 0.35s cubic-bezier(.4, 0, .2, 1);
      z-index: 2001;
      display: flex;
      flex-direction: column;
      pointer-events: auto;
    }

    .info-sidebar.visible {
      transform: translateX(0);
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 18px 20px 12px 20px;
      border-bottom: 1px solid #eee;
      background: #f8f8f8;
    }

    .sidebar-header .close-btn {
      font-size: 1.7rem;
      color: #888;
      background: none;
      border: none;
      cursor: pointer;
      line-height: 1;
      transition: color 0.2s;
    }

    .sidebar-header .close-btn:hover {
      color: #c00;
    }

    .sidebar-content {
      padding: 18px 20px;
      overflow-y: auto;
      flex: 1;
      font-size: 15px;
    }

    @media (max-width: 900px) {
      .info-sidebar {
        width: 50vw;
        min-width: 0;
      }
    }

    @media (max-width: 600px) {
      .info-sidebar {
        width: 100vw;
        max-width: none;
        min-width: 0;
      }

      .sidebar-header,
      .sidebar-content {
        padding-left: 12px;
        padding-right: 12px;
      }
    }

    #attribute-table-content {
      overflow-x: auto;
      overflow-y: auto;
      width: 100%;
      max-height: 60vh;
    }

    #attribute-table-content table {
      min-width: 1200px;
      width: max-content;
    }

    .mouse-position-control {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      font-family: monospace;
    }

    /* Custom scale bar styling */
    .leaflet-control-scale {
      background: rgba(30, 30, 30, 0.85);
      border-radius: 7px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.18);
      padding: 7px 8px 7px 8px;
      /* less horizontal padding */
      font-family: 'Segoe UI', 'Georgia', serif;
      font-size: 15px;
      color: #fff;
      border: none;
      margin-bottom: 24px;
      margin-left: 10px;
      /* smaller left margin */
      font-weight: 600;
      letter-spacing: 0.5px;
      text-align: left;
      /* left align */
      min-width: 70px;
      /* prevents too much shrinking */
      max-width: 200px;
    }

    .leaflet-control-scale-line {
      background: #fff;
      color: #222;
      border-radius: 3px;
      border: none;
      height: 10px;
      line-height: 10px;
      font-size: 13px;
      margin: 4px 0;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.13);
      font-weight: bold;
      text-shadow: 0 1px 2px #fff, 0 0 2px #fff;
      position: relative;
      padding-bottom: 2px;
    }

    .leaflet-control-scale-line:not(:last-child) {
      margin-bottom: 4px;
    }

    /* Gold accent line below the scale bar */
    .leaflet-control-scale-line:after {
      content: '';
      display: block;
      width: 100%;
      height: 3px;
      background: linear-gradient(90deg, #c19a6b 0%, #fffbe6 100%);
      border-radius: 2px;
      margin-top: 2px;
    }

    #north-arrow {
      position: fixed;
      top: 22px;
      right: 22px;
      z-index: 1200;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.13);
      padding: 8px 10px 2px 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      /* So it doesn't block map controls */
      transition: background 0.2s;
    }

    #north-arrow svg {
      display: block;
    }

    .wms-label {
      pointer-events: none;
      font-family: Georgia, serif;
      font-size: 12px;
      text-shadow: 0 1px 2px #fff;
    }

    /* Search Container and Suggestions - Enhanced Adaptive Version */
    .search-container {
      position: relative;
      width: 100%;
    }

    .search-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10000;
      /* Increased z-index to ensure it's above other elements */
      display: none;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      /* Adaptive positioning */
      transform-origin: top;
    }

    /* Adaptive positioning - show above if not enough space below */
    .search-suggestions.above {
      top: auto;
      bottom: 100%;
      border-top: 1px solid #ddd;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.1);
    }

    .search-suggestions.show {
      display: block;
    }

    /* Ensure suggestions are always visible within viewport */
    .search-suggestions {
      max-height: min(200px, calc(100vh - 200px));
      overflow-y: auto;
      overflow-x: hidden;
    }

    /* Custom scrollbar for suggestions */
    .search-suggestions::-webkit-scrollbar {
      width: 6px;
    }

    .search-suggestions::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }

    .search-suggestions::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }

    .search-suggestions::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    /* Ensure dropdown content doesn't clip suggestions */
    .dropdown-content {
      overflow: visible !important;
    }

    /* Make sure search dropdown has proper positioning */
    #search-dropdown {
      overflow: visible !important;
      z-index: 9999;
    }

    #search-dropdown .dropdown-section {
      overflow: visible !important;
    }

    .suggestion-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      font-size: 13px;
      transition: background-color 0.2s ease;
    }

    .suggestion-item:hover {
      background-color: #f8f9fa;
    }

    .suggestion-item.active {
      background-color: #e3f2fd;
      border-left: 3px solid #2196f3;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item .suggestion-name {
      font-weight: 500;
      color: #333;
    }

    .suggestion-item .suggestion-details {
      font-size: 11px;
      color: #666;
      margin-top: 2px;
    }

    .suggestion-item .suggestion-type {
      display: inline-block;
      background: #e9ecef;
      color: #495057;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      margin-left: 8px;
    }

    /* Force scrollbar for Utility Tools dropdown if content overflows */
    #utilityTools-dropdown {
      max-height: 350px !important;
      overflow-y: auto !important;
    }

    .buffer-table-container {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 9999;
      background: #fff;
      box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.08);
      padding: 0;
      max-height: 220px;
      overflow-x: auto;
      border-top: 2px solid #00ffff;
    }

    .buffer-table-scroll {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 180px;
    }

    .buffer-table {
      border-collapse: separate;
      border-spacing: 0;
      width: 100%;
      min-width: 900px;
      font-family: 'Fira Mono', 'Consolas', 'Menlo', 'monospace', system-ui, sans-serif;
      font-size: 14px;
      background: #fff;
    }

    .buffer-table th {
      background: #fff;
      color: #111;
      font-weight: bold;
      padding: 6px 10px;
      border-bottom: 2px solid #00ffff;
      border-right: 1px solid #e0e0e0;
      text-align: left;
      position: sticky;
      top: 0;
      z-index: 2;
    }

    .buffer-table td {
      background: #00ffff;
      color: #111;
      padding: 6px 10px;
      border-right: 1px solid #e0e0e0;
      border-bottom: 1px solid #b2f5f5;
      min-width: 120px;
      max-width: 220px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .buffer-table tr:hover td {
      background: #b2f5f5;
    }

    .buffer-table tr {
      height: 30px;
    }

    .buffer-table th:last-child,
    .buffer-table td:last-child {
      border-right: none;
    }

    .buffer-table tr:last-child td {
      border-bottom: none;
    }

    .buffer-table-filter {
      padding: 8px 0 4px 0;
      background: #fff;
      border-bottom: 1px solid #00ffff;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .buffer-table-filter input {
      padding: 4px 8px;
      border: 1px solid #00cccc;
      border-radius: 4px;
      font-size: 14px;
    }
  </style>
  <!-- Add these libraries in the head section -->
  <script src="https://unpkg.com/dxf@4.7.0/dist/dxf.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js"></script>
  <script src="https://unpkg.com/leaflet-dxf@1.0.0/dist/leaflet-dxf.min.js"></script>
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <!-- In your <head> or before your closing </body> tag -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />

</head>

<body>
  <div class="container">
    <!-- Navbar -->
    <nav id="navbar" class="navbar">
      <div class="navbar-brand">
        <i class="fas fa-globe"></i>
        S.T.B.T.T GeoPortal
      </div>

      <div id="navbarContent" class="navbar-content">
        <!-- Basemaps -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('basemaps', event)" title="Basemaps">
            <i class="fas fa-map"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="basemaps-dropdown">
            <div class="dropdown-section">
              <div class="basemap-gallery">
                <div class="basemap-item active" onclick="changeBasemap('osm')" data-basemap="osm">
                  <div class="basemap-label">OpenStreetMap</div>
                </div>
                <div class="basemap-item" onclick="changeBasemap('satellite')" data-basemap="satellite">
                  <div class="basemap-label">Satellite</div>
                </div>
                <div class="basemap-item" onclick="changeBasemap('terrain')" data-basemap="terrain">
                  <div class="basemap-label">Terrain</div>
                </div>
                <div class="basemap-item" onclick="changeBasemap('dark')" data-basemap="dark">
                  <div class="basemap-label">Dark Mode</div>
                </div>
                <div class="basemap-item" onclick="changeBasemap('esri_topo')" data-basemap="esri_topo">
                  <div class="basemap-label">Esri Topography</div>
                </div>
                <div class="basemap-item" onclick="changeBasemap('esri_ocean')" data-basemap="esri_ocean">
                  <div class="basemap-label">Esri Ocean</div>
                </div>
                <div class="basemap-item" onclick="changeBasemap('google_hybrid')" data-basemap="google_hybrid">
                  <div class="basemap-label">Google Hybrid</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- WMS Layers -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('wmsLayers', event)" title="Admin Boundaries">
            <i class="fas fa-layer-group"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="wmsLayers-dropdown">
            <div class="dropdown-section">
              <h4>Select Layer</h4>
              <select id="layerSelector" class="layer-selector">
                <option value="">Select Layer</option>
                <option value="india_boundary">India Boundary</option>
                <option value="maharashtra_boundary">Maharashtra Boundary</option>
                <option value="division_boundary">Division Boundary</option>
                <option value="district_boundary">District Boundary</option>
                <option value="taluka_boundary">Taluka Boundary</option>
                <option value="village_boundary">Village Boundary</option>
                <option value="hq_tal_dist_div">HQ_TAL_DIST_DIV</option>
                <option value="tuljapur_taluka">Tuljapur Taluka</option>
                <option value="tuljapur_village">Tuljapur Village</option>
                <option value="tuljapur_municipal_council">Tuljapur Municipal Council</option>
                <option value="tuljabhavani_temple_trust">TuljaBhavani Temple Trust acquisition area</option>
                <option value="tuljabhavani_temple_complex">TuljaBhavani Temple Complex</option>
                <option value="drone_based_contour">Drone Based Contour</option>
                <option value="drone_based_masterplan">Drone Based Masterplan</option>
                <option value="monument_locations">Monument Locations</option>
              </select>
              <div id="legendContainer" class="legend-container">
                <h4>Legend</h4>
                <div id="legendContent"></div>
              </div>
            </div>
          </div>
        </div>
        <!-- Raster Layers -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('rasterLayers', event)" title="Select Raster">
            <i class="fas fa-image"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="rasterLayers-dropdown">
            <div class="dropdown-section">
              <h4>Select Raster</h4>
              <select id="rasterSelector" class="layer-selector">
                <option value="">Select Raster</option>
                <option value="Orthomosaic_Tuljapur_City">Orthomosaic_Tuljapur_City</option>
                <option value="temple_complex_raster">temple complex raster</option>
                <option value="temple_complex_dem">Temple Complex DEM</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Layer Visibility -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('layerVisibility', event)" title="Layer Control">
            <i class="fas fa-eye"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="layerVisibility-dropdown">
            <div class="dropdown-section">
              <h4>Active Layers</h4>
              <div id="layerList">
                <!-- Layer items will be populated here -->
              </div>
            </div>
          </div>
        </div>

        <!-- Draw Tools -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('drawTools', event)" title="Draw Tools">
            <i class="fas fa-draw-polygon"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="drawTools-dropdown">
            <div class="dropdown-section">
              <h4>Drawing Tools</h4>
              <button class="sub-btn" onclick="selectDrawTool('point')">
                <i class="fas fa-map-pin"></i> Draw Point
              </button>
              <button class="sub-btn" onclick="selectDrawTool('polyline')">
                <i class="fas fa-route"></i> Draw Polyline
              </button>
              <button class="sub-btn" onclick="selectDrawTool('polygon')">
                <i class="fas fa-draw-polygon"></i> Draw Polygon
              </button>
              <button class="sub-btn" onclick="selectDrawTool('rectangle')">
                <i class="fas fa-square"></i> Draw Rectangle
              </button>
              <button class="sub-btn" onclick="selectDrawTool('circle')">
                <i class="fas fa-circle"></i> Draw Circle
              </button>
              <button class="sub-btn" onclick="selectDrawTool('edit')">
                <i class="fas fa-edit"></i> Edit Features
              </button>
              <button class="sub-btn" onclick="selectDrawTool('delete')">
                <i class="fas fa-trash"></i> Delete Features
              </button>
              <button class="sub-btn" onclick="clearAllDrawings()">
                <i class="fas fa-eraser"></i> Clear All
              </button>
            </div>
          </div>
        </div>

        <!-- Measurement Tools -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('measurements', event)" title="Measurements">
            <i class="fas fa-ruler"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="measurements-dropdown">
            <div class="dropdown-section">
              <h4>Measurement Tools</h4>
              <button class="sub-btn" onclick="startMeasurement('distance')">
                <i class="fas fa-ruler-horizontal"></i> Measure Distance
              </button>
              <button class="sub-btn" onclick="startMeasurement('area')">
                <i class="fas fa-vector-square"></i> Measure Area
              </button>
              <button class="sub-btn" onclick="clearMeasurements()">
                <i class="fas fa-times"></i> Clear Measurements
              </button>
            </div>
          </div>
        </div>

        <!-- Advanced Tools -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('advancedTools', event)" title="Advanced Tools">
            <i class="fas fa-tools"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="advancedTools-dropdown">
            <div class="dropdown-section">
              <h4>Advanced Tools</h4>
              <button class="sub-btn" onclick="findMyLocation()">
                <i class="fas fa-location-arrow"></i> Find My Location
              </button>
              <button class="sub-btn" onclick="reverseGeocoding()">
                <i class="fas fa-map-marker-alt"></i> Reverse Geocoding
              </button>
              <button class="sub-btn" onclick="getPointElevation()">
                <i class="fas fa-mountain"></i> Get Point Elevation
              </button>
              <button id="elevation-profile-btn" class="sub-btn">
                <i class="fas fa-chart-line"></i> Elevation Profile
              </button>
              <button class="sub-btn" onclick="findIntersections()">
                <i class="fas fa-crosshairs"></i> Find Intersections
              </button>
              <button class="sub-btn" onclick="performBufferAnalysis()">
                <i class="fas fa-circle"></i> Buffer Analysis
              </button>
              <button class="sub-btn" onclick="toggleLegend()">
                <i class="fas fa-list"></i> Show Legend
              </button>
              <button class="sub-btn" onclick="clearAdvancedTools()">
                <i class="fas fa-eraser"></i> Clear All
              </button>

            </div>
          </div>
        </div>

        <!-- Utility Tools -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('utilityTools', event)" title="Utility Tools">
            <i class="fas fa-cogs"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="utilityTools-dropdown">
            <div class="dropdown-section">
              <h4>Grid & Reference</h4>
              <button class="sub-btn" onclick="toggleUtilityTool('gridOverlay')">
                <i class="fas fa-th"></i> Grid Overlay
              </button>
              <button class="sub-btn" onclick="toggleUtilityTool('graticule')">
                <i class="fas fa-globe"></i> Graticule
              </button>
              <button class="sub-btn" onclick="toggleUtilityTool('crosshairs')">
                <i class="fas fa-crosshairs"></i> Crosshairs
              </button>
            </div>
            <div class="dropdown-section">
              <h4>Position & Navigation</h4>
              <button class="sub-btn" onclick="toggleUtilityTool('mousePosition')">
                <i class="fas fa-mouse-pointer"></i> Mouse Position
              </button>
              <button class="sub-btn" onclick="activateUtilityTool('distanceFromPoint')">
                <i class="fas fa-bullseye"></i> Distance from Point
              </button>
              <button class="sub-btn" onclick="activateUtilityTool('bearingCalculator')">
                <i class="fas fa-compass"></i> Bearing Calculator
              </button>
            </div>
            <div class="dropdown-section">
              <h4>Conversion Tools</h4>
              <button class="sub-btn" onclick="openUtilityTool('coordinateConverter')">
                <i class="fas fa-exchange-alt"></i> Coordinate Converter
              </button>
              <button class="sub-btn" onclick="toggleUtilityTool('unitsConverter')">
                <i class="fas fa-ruler-combined"></i> Units Converter
              </button>
            </div>
            <div class="dropdown-section">
              <h4>Analysis Tools</h4>
              <button class="sub-btn" onclick="activateUtilityTool('slopeAnalysis')">
                <i class="fas fa-chart-line"></i> Slope Analysis
              </button>
            </div>
          </div>
        </div>

        <!-- Get Information Tool -->
        <div class="navbar-group">
          <button class="feature-btn" id="infoToolBtn" title="Get Information">
            <i class="fas fa-info-circle"></i>
          </button>
        </div>

        <!-- Attribute Table Button (moved here) -->
        <div class="navbar-group">
          <button class="feature-btn" id="attributeTableBtn" title="Attribute Table">
            <i class="fas fa-table"></i>
          </button>
        </div>

        <!-- Toggle 3D View -->
        <div class="navbar-group">
          <button id="map-view-toggle-btn" class="feature-btn" onclick="toggleMapView()" title="Toggle 3D View">
            <i class="fas fa-globe-americas"></i>
          </button>
        </div>

        <!-- Import CAD -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="document.getElementById('cadFileInput').click()" title="Import CAD">
            <i class="fas fa-drafting-compass"></i>
          </button>
          <input type="file" id="cadFileInput" accept=".dxf" style="display: none" onchange="handleCADFile(event)" />
        </div>

        <!-- View CAD Online -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="window.open('https://web.autocad.com/login', '_blank')"
            title="View CAD Online">
            <i class="fas fa-drafting-compass"></i>
          </button>
        </div>

        <!-- Search -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('search', event)" title="Search">
            <i class="fas fa-search"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="search-dropdown">
            <div class="dropdown-section">
              <h4>Search Places</h4>
              <div class="search-container">
                <input type="text" id="searchInput" placeholder="Search for places..." class="search-input"
                  autocomplete="off" />
                <div id="searchSuggestions" class="search-suggestions"></div>
              </div>
              <button class="sub-btn" onclick="performSearch()">
                <i class="fas fa-search"></i> Search
              </button>
            </div>
          </div>
        </div>

        <!-- File Upload -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('fileUpload', event)" title="File Upload">
            <i class="fas fa-upload"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="fileUpload-dropdown">
            <div class="dropdown-section">
              <h4>Upload Files</h4>
              <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-cloud-upload-alt" style="
                      font-size: 1.5rem;
                      color: #007bff;
                      margin-bottom: 8px;
                    "></i>
                <p style="font-size: 12px">Click to upload files</p>
                <p style="font-size: 10px; color: #666; margin-top: 4px">
                  Supports: GeoJSON, KML, GPX, Shapefile (ZIP)
                </p>
                <input type="file" id="fileInput" accept=".geojson,.kml,.gpx,.json,.zip,.shp" multiple
                  onchange="handleFileUpload(event)" />
              </div>
            </div>
          </div>
        </div>

        <!-- Export -->
        <div class="navbar-group">
          <button class="feature-btn" onclick="toggleDropdown('export', event)" title="Export">
            <i class="fas fa-file-export"></i>
            <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-content" id="export-dropdown">
            <div class="dropdown-section">
              <h4>Export Map Image</h4>
              <button class="sub-btn" onclick="exportMapAsImage('png')">
                <i class="fas fa-image"></i> Export as PNG
              </button>
              <button class="sub-btn" onclick="exportMapAsImage('jpg')">
                <i class="fas fa-image"></i> Export as JPG
              </button>
            </div>
            <div class="dropdown-section">
              <h4>Export Features</h4>
              <button class="sub-btn" onclick="exportFeatures('geojson')">
                <i class="fas fa-file-code"></i> Export as GeoJSON
              </button>
              <button class="sub-btn" onclick="exportFeatures('kml')">
                <i class="fas fa-file-alt"></i> Export as KML
              </button>
              <button class="sub-btn" onclick="exportFeatures('shapefile')">
                <i class="fas fa-file-archive"></i> Export as Shapefile
              </button>
            </div>
            <div class="dropdown-section">
              <h4>Share & Report</h4>
              <button class="sub-btn" onclick="shareMapView()">
                <i class="fas fa-share-alt"></i> Share Map View
              </button>
              <button class="sub-btn" onclick="generatePDFReport()">
                <i class="fas fa-file-pdf"></i> Generate PDF Report
              </button>
              <button id="export-elevation-png" class="sub-btn">
                <i class="fas fa-image"></i> Export Elevation Profile as PNG
              </button>

            </div>
          </div>
        </div>

        <!-- Routing Button -->
        <div class="navbar-group">
          <button class="feature-btn" id="routingBtn" title="Route Directions">
            <i class="fas fa-route"></i>
          </button>
        </div>
      </div>
    </nav>

    <!-- Map Container -->
    <div id="map-container">
      <div id="map"></div>
      <div id="coordinates"></div>
    </div>

    <!-- WMS Layer Info Panel -->
    <div id="wms-info-panel" class="panel">
      <!-- Add your existing content here -->
    </div>

    <!-- Info Sidebar -->
    <div id="feature-info-panel" class="info-sidebar">
      <div class="sidebar-header">
        <span>Layer Information</span>
        <button class="close-btn" onclick="closeInfoPanel()">&times;</button>
      </div>
      <div id="feature-list" class="sidebar-content">
        <!-- Feature info will be injected here -->
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- CAD Import Libraries -->
  <script src="https://unpkg.com/dxf@4.7.0/dist/dxf.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js"></script>
  <script src="https://unpkg.com/leaflet-dxf@1.0.0/dist/leaflet-dxf.min.js"></script>

  <!-- Custom Scripts -->
  <script src="cad-import.js"></script>

  <script>
    // Global variables
    let map;
    let cesiumViewer;
    let is3D = false;
    let currentUnit = 'metric';
    let drawControl;
    let drawnItems;
    let basemaps = {};
    let currentBasemap = "osm";
    let layerControl;
    let overlayLayers = {};
    let measurementLayer;
    let isDrawing = false;
    let currentDrawTool = null;
    let currentWMSLayer = null;
    let wmsLayers = {};
    let isMeasuring = false;
    let measurementType = null;
    let isNavbarExpanded = false;
    let infoToolActive = false;
    let infoToolCursor = null;
    let highlightedFeatureLayer = null;
    let contourVectorLayer = null; // To hold the invisible clickable layer
    let infoVectorLayer = null; // To hold the invisible clickable layer
    let infoLayerName = null; // To track which layer the info tool is for
    const featureInfoById = {}; // To store all feature properties by OBJECTID
    let attributeTableLoaded = false;
    let advancedToolsLayerGroup;
    let bearingLine = null;
    var gridLayer = null;
    var graticuleLayer = null;
    var crosshairsMarker = null;
    let distanceCircles = [];
    let statsText = "";
    const wmsLayerLabelZoomLevels = {
      "india_boundary": 7,
      "maharashtra_boundary": 7,
      "division_boundary": 7,
      "district_boundary": 7,
      "taluka_boundary": 7,
      "village_boundary": 7,
      "hq_tal_dist_div": 13,
      "tuljapur_taluka": 16,
      "tuljapur_village": 14,
      "tuljapur_municipal_council": 16,
      "tuljabhavani_temple_trust": 17,
      "tuljabhavani_temple_complex": 18,
      "drone_based_contour": 16,
      "drone_based_masterplan": 15,
      "monument_locations": 17
    };

    let demClickHandler = null;
    let demFeatures = [];
    var utilityToolsState = {
      gridOverlay: false,
      graticule: false,
      crosshairs: false,
      mousePosition: false,
      unitsConverter: false
    };

    const wmsLegendInfo = {
      india_boundary: {
        title: "India Administrative Boundary",
        color: "#ff6b6b",
        description: "International boundary of India",
      },
      maharashtra_boundary: {
        title: "Maharashtra State Boundary",
        color: "#4ecdc4",
        description: "State boundary of Maharashtra",
      },
      district_boundary: {
        title: "District Boundaries",
        color: "#45b7d1",
        description: "Administrative district boundaries",
      },
      division_boundary: {
        title: "Division Boundaries",
        color: "#f9ca24",
        description: "Administrative division boundaries",
      },
      taluka_boundary: {
        title: "Taluka Boundaries",
        color: "#f0932b",
        description: "Sub-district administrative boundaries",
      },
      village_boundary: {
        title: "Village Boundaries",
        color: "#eb4d4b",
        description: "Village-level administrative boundaries",
      },
      hq_tal_dist_div: {
        title: "Administrative Headquarters",
        color: "#6c5ce7",
        description: "Taluka, District and Division headquarters",
      },
    };

    function toggleMapView() {
      // If you want to pass the current map center and zoom to 3D mode:
      if (typeof map !== "undefined" && map.getCenter && map.getZoom) {
        const center = map.getCenter();
        const zoom = map.getZoom();
        window.location.href = `Geo3D.html?lat=${center.lat}&lng=${center.lng}&zoom=${zoom}`;
      } else {
        // Fallback: just go to 3D mode
        window.location.href = "Geo3D.html";
      }
    }

    function initCesium() {
      // IMPORTANT: Replace with your own Cesium ION access token.
      Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlZWY2MzA0ZC03NmU4LTRjOTEtODQwNi1jYTdkNzJlMWE4MTUiLCJpZCI6MzE0NDcwLCJpYXQiOjE3NTA1OTUwNTN9.FDUqMDehocIQpHURWp-EsFICW-jcKn7Cf_jGhWeYRCY';

      cesiumViewer = new Cesium.Viewer('cesiumContainer', {
        terrain: Cesium.Terrain.fromWorldTerrain(),
        // We use our own navbar, so disable most of Cesium's default widgets.
        animation: false,
        baseLayerPicker: false,
        fullscreenButton: false,
        geocoder: false,
        homeButton: false,
        infoBox: false,
        sceneModePicker: false,
        selectionIndicator: false,
        timeline: false,
        navigationHelpButton: false,
      });

      // Set initial camera view to India
      cesiumViewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(78.9629, 20.5937, 4000000), // Lng, Lat, Altitude
      });
    }

    function syncFeaturesToCesium() {
      if (!cesiumViewer) return;

      // Clear any existing data
      cesiumViewer.dataSources.removeAll();

      // Add drawn items from Leaflet
      if (drawnItems && drawnItems.getLayers().length > 0) {
        const geojson = drawnItems.toGeoJSON();
        Cesium.GeoJsonDataSource.load(geojson, {
          stroke: Cesium.Color.HOTPINK,
          fill: Cesium.Color.PINK.withAlpha(0.5),
          strokeWidth: 3,
        }).then(dataSource => {
          cesiumViewer.dataSources.add(dataSource);
        });
      }

      // Add the current WMS layer
      if (currentWMSLayer && wmsLayers[currentWMSLayer]) {
        const wmsLayerInfo = wmsLayers[currentWMSLayer];
        const wmsProvider = new Cesium.WebMapServiceImageryProvider({
          url: wmsLayerInfo._url,
          layers: wmsLayerInfo.wmsParams.layers,
          parameters: {
            transparent: true,
            format: 'image/png'
          }
        });
        cesiumViewer.imageryLayers.addImageryProvider(wmsProvider);
      }
    }

    // Export Functions - Making them globally accessible
    window.exportMapAsImage = function (format) {
      console.log('Starting map export...');
      if (!map) {
        alert("Map not initialized");
        return;
      }

      // Create a temporary container for the map
      const container = document.createElement('div');
      container.style.width = map.getSize().x + 'px';
      container.style.height = map.getSize().y + 'px';
      container.style.position = 'absolute';
      container.style.left = '-9999px';
      document.body.appendChild(container);

      // Clone the map container
      const mapClone = map.getContainer().cloneNode(true);
      container.appendChild(mapClone);

      // Use html2canvas to capture the map
      html2canvas(mapClone, {
        useCORS: true,
        allowTaint: true,
        backgroundColor: null,
        scale: 2 // Higher quality
      }).then(canvas => {
        // Convert to image
        const imgData = canvas.toDataURL(`image/${format}`);

        // Create download link
        const link = document.createElement('a');
        link.download = `map-export.${format}`;
        link.href = imgData;
        link.click();

        // Cleanup
        document.body.removeChild(container);
      }).catch(error => {
        console.error('Error exporting map:', error);
        alert('Error exporting map. Please try again.');
      });
    };

    window.exportFeatures = function (format) {
      console.log('Starting feature export...');
      console.log('Map:', map);
      console.log('Drawn Items:', drawnItems);

      if (!map) {
        alert("Map not initialized");
        return;
      }

      if (!drawnItems) {
        console.log('No drawnItems found, checking for drawn items in map...');
        // Try to find drawn items in the map
        const layers = map._layers;
        let foundDrawnItems = null;

        for (let key in layers) {
          if (layers[key] instanceof L.FeatureGroup) {
            foundDrawnItems = layers[key];
            break;
          }
        }

        if (!foundDrawnItems) {
          alert("No drawing layer found. Please draw some features first.");
          return;
        }
        drawnItems = foundDrawnItems;
      }

      console.log('Getting GeoJSON from drawn items...');
      const features = drawnItems.toGeoJSON();
      console.log('Features:', features);

      if (!features || !features.features || features.features.length === 0) {
        alert("No features selected. Please draw some features first.");
        return;
      }

      let data, mimeType, extension;
      try {
        switch (format) {
          case 'geojson':
            console.log('Exporting as GeoJSON...');
            data = JSON.stringify(features, null, 2);
            mimeType = 'application/json';
            extension = 'geojson';
            break;
          case 'kml':
            console.log('Exporting as KML...');
            data = toKML(features);
            mimeType = 'application/vnd.google-earth.kml+xml';
            extension = 'kml';
            break;
          case 'shapefile':
            alert("Shapefile export requires server-side processing. This feature is not available in the browser version.");
            return;
          default:
            alert("Unsupported format");
            return;
        }

        console.log('Creating download...');
        // Create download link
        const blob = new Blob([data], { type: mimeType });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `map-features.${extension}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);

        console.log('Export completed successfully');
      } catch (error) {
        console.error('Error during export:', error);
        alert('Error exporting features: ' + error.message);
      }
    };

    window.shareMapView = function () {
      if (!map) {
        alert("Map not initialized");
        return;
      }

      const center = map.getCenter();
      const zoom = map.getZoom();
      const url = `${window.location.origin}${window.location.pathname}?lat=${center.lat}&lng=${center.lng}&zoom=${zoom}`;

      // Create a temporary input element
      const input = document.createElement('input');
      input.value = url;
      document.body.appendChild(input);
      input.select();

      try {
        // Try using the modern clipboard API
        navigator.clipboard.writeText(url).then(() => {
          alert('Map view URL copied to clipboard!');
        }).catch(() => {
          // Fallback to execCommand
          document.execCommand('copy');
          alert('Map view URL copied to clipboard!');
        });
      } catch (error) {
        console.error('Error copying to clipboard:', error);
        alert('Error copying URL. Please copy it manually: ' + url);
      }

      document.body.removeChild(input);
    };

    window.generatePDFReport = function () {
      if (!map) {
        alert("Map not initialized");
        return;
      }

      // Create a temporary container for the report
      const container = document.createElement('div');
      container.style.width = '800px';
      container.style.padding = '20px';
      document.body.appendChild(container);

      // Get the legend HTML (if visible)
      let legendHTML = "";
      const legendContent = document.getElementById("legendContent");
      if (legendContent && legendContent.innerHTML.trim() !== "") {
        legendHTML = `<div style="margin-top:20px;"><h3>Legend</h3>${legendContent.innerHTML}</div>`;
      } else {
        // Fallback static legend
        legendHTML = `
            <div style="margin-top:20px;">
              <h3>Legend</h3>
              <div class="legend-item"><span style="display:inline-block;width:20px;height:3px;background:#ff6b6b;margin-right:10px;border-radius:2px;"></span>India Boundary</div>
              <div class="legend-item"><span style="display:inline-block;width:20px;height:3px;background:#4ecdc4;margin-right:10px;border-radius:2px;"></span>Maharashtra Boundary</div>
              <div class="legend-item"><span style="display:inline-block;width:20px;height:3px;background:#45b7d1;margin-right:10px;border-radius:2px;"></span>District Boundary</div>
              <!-- Add more as needed -->
            </div>
          `;
      }

      // North arrow SVG
      const northArrowSVG = `
          <div style="margin-top:20px;display:flex;align-items:center;">
            <svg width="40" height="60" viewBox="0 0 40 60">
              <polygon points="20,5 30,40 20,35 10,40" style="fill:#333;stroke:#222;stroke-width:2"/>
              <text x="20" y="55" text-anchor="middle" font-size="18" fill="#222" font-family="Arial">N</text>
            </svg>
            <span style="margin-left:10px;font-size:14px;">North</span>
          </div>
        `;

      // Static scale bar SVG (for visual effect)
      const scaleBarSVG = `
          <div style="margin-top:10px;">
            <svg width="120" height="30">
              <rect x="10" y="10" width="100" height="10" fill="#222"/>
              <rect x="10" y="10" width="50" height="10" fill="#fff"/>
              <text x="10" y="28" font-size="12" fill="#222">0</text>
              <text x="60" y="28" font-size="12" fill="#222">500 m</text>
              <text x="110" y="28" font-size="12" fill="#222">1 km</text>
            </svg>
          </div>
        `;

      // Capture map as image
      html2canvas(map.getContainer(), {
        useCORS: true,
        allowTaint: true,
        backgroundColor: null,
        scale: 2 // Higher quality
      }).then(canvas => {
        // Create report content
        const report = document.createElement('div');
        report.innerHTML = `
            <h2>Map Report</h2>
            <p>Generated on: ${new Date().toLocaleString()}</p>
            <p>Center: ${map.getCenter().lat.toFixed(6)}, ${map.getCenter().lng.toFixed(6)}</p>
            <p>Zoom Level: ${map.getZoom()}</p>
            <img src="${canvas.toDataURL()}" style="width: 100%; margin: 20px 0;">
            ${legendHTML}
            ${northArrowSVG}
            ${scaleBarSVG}
            <h3>Active Layers:</h3>
            <ul>
              ${Object.keys(overlayLayers).map(layer => `<li>${layer}</li>`).join('')}
            </ul>
          `;
        container.appendChild(report);

        // Generate PDF
        const opt = {
          margin: 1,
          filename: 'map-report.pdf',
          image: { type: 'jpeg', quality: 0.98 },
          html2canvas: { scale: 2 },
          jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }
        };

        html2pdf().set(opt).from(container).save();

        // Cleanup
        document.body.removeChild(container);
      }).catch(error => {
        console.error('Error generating PDF:', error);
        alert('Error generating PDF report. Please try again.');
      });
    };

    // Helper function for KML conversion
    function toKML(geojson) {
      console.log('Converting to KML...');
      let kml = '<?xml version="1.0" encoding="UTF-8"?>\n';
      kml += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
      kml += '<Document>\n';

      geojson.features.forEach((feature, index) => {
        console.log(`Processing feature ${index}:`, feature);

        if (feature.geometry.type === 'Point') {
          kml += '<Placemark>\n';
          kml += `<Point>\n<coordinates>${feature.geometry.coordinates.join(',')}</coordinates>\n</Point>\n`;
          kml += '</Placemark>\n';
        } else if (feature.geometry.type === 'LineString') {
          kml += '<Placemark>\n';
          kml += `<LineString>\n<coordinates>${feature.geometry.coordinates.map(coord => coord.join(',')).join(' ')}</coordinates>\n</LineString>\n`;
          kml += '</Placemark>\n';
        } else if (feature.geometry.type === 'Polygon') {
          kml += '<Placemark>\n';
          kml += `<Polygon>\n<outerBoundaryIs>\n<LinearRing>\n<coordinates>${feature.geometry.coordinates[0].map(coord => coord.join(',')).join(' ')}</coordinates>\n</LinearRing>\n</outerBoundaryIs>\n</Polygon>\n`;
          kml += '</Placemark>\n';
        } else {
          console.warn(`Unsupported geometry type: ${feature.geometry.type}`);
        }
      });

      kml += '</Document>\n</kml>';
      console.log('KML conversion completed');
      return kml;
    }

    // Initialize the map
    function initializeMap() {
      if (map) {
        console.log("Map already initialized");
        return;
      }
      // Create map
      map = L.map("map").setView([20.5937, 78.9629], 5); // India center

      // Add Leaflet scale bar control (bottom left)
      L.control.scale({
        position: 'bottomleft',
        imperial: false,
        maxWidth: 200,
        updateWhenIdle: true
      }).addTo(map);

      // --- WMS Layer Name Mapping ---
      // Moved to this scope to be accessible by click handlers and layer initializers
      const wmsLayerNames = {
        "allshapefiles:India_Project": "India Boundary",
        "allshapefiles:Maha_State_Project": "Maharashtra Boundary",
        "allshapefiles:Division_Project": "Division Boundary",
        "allshapefiles:District_Project": "District Boundary",
        "allshapefiles:Taluka_Project": "Taluka Boundary",
        "allshapefiles:Village_Project": "Village Boundary"
      };

      // --- WFS Info Tool Integration ---
      function wmsToWfsUrl(wmsUrl, layerName, latlng, srs = "EPSG:4326") {
        // Build a bbox around the clicked point. A larger buffer makes it easier to select features.
        const buffer = 0.01; // Increased buffer to ~1km for easier feature selection
        const minx = latlng.lng - buffer;
        const miny = latlng.lat - buffer;
        const maxx = latlng.lng + buffer;
        const maxy = latlng.lat + buffer;
        const bbox = `${minx},${miny},${maxx},${maxy}`;
        // Convert WMS endpoint to WFS
        const wfsUrl = wmsUrl.replace("/wms", "/wfs");
        const params = [
          "service=WFS",
          "version=1.1.0",
          "request=GetFeature",
          `typeName=${encodeURIComponent(layerName)}`,
          "outputFormat=application/json",
          `bbox=${bbox}`,
          `srsName=${srs}`
        ].join("&");
        return `${wfsUrl}?${params}`;
      }

      map.on('click', function (e) {
        if (!infoToolActive) return;
        // Find the active WMS layer and its info
        let activeLayerName = null;
        let activeWmsUrl = null;
        for (const [name, layer] of Object.entries(overlayLayers)) {
          if (map.hasLayer(layer) && layer.wmsParams && layer.wmsParams.layers) {
            // Find the first active layer from our known list that is currently visible
            const visibleLayers = layer.wmsParams.layers.split(',');
            for (const visibleLayer of visibleLayers) {
              if (wmsLayerNames[visibleLayer]) {
                activeLayerName = visibleLayer;
                break;
              }
            }
            activeWmsUrl = layer._url;
            if (activeLayerName) break;
          }
        }

        if (!activeLayerName || !activeWmsUrl) {
          // L.popup().setLatLng(e.latlng).setContent("No WMS layer active.").openOn(map);
          return;
        }
        // Build WFS URL for the clicked point
        const wfsUrl = wmsToWfsUrl(activeWmsUrl, activeLayerName, e.latlng);
        const proxyWfsUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(wfsUrl)}`;

        // Fetch features from WFS via the proxy
        fetch(proxyWfsUrl)
          .then(response => response.json())
          .then(data => {
            console.log("WFS features:", data.features[0]); // <-- Add this here
            if (data.features && data.features.length > 0) {
              // Show the first feature's properties
              const props = data.features[0].properties;
              let popupContent = '<div style="max-height: 200px; overflow-y: auto;">';
              popupContent += `<h6>${wmsLayerNames[activeLayerName] || 'Feature Info'}</h6>`; // Use friendly name
              Object.keys(props).forEach(key => {
                if (key !== 'bbox') { // Exclude bbox from properties
                  popupContent += `<b>${key}:</b> ${props[key]}<br>`;
                }
              });
              popupContent += "</div>";
              L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map);
            } else {
              L.popup().setLatLng(e.latlng).setContent("No feature found.").openOn(map);
            }
          })
          .catch(err => {
            console.error("WFS fetch error:", err);
            L.popup().setLatLng(e.latlng).setContent("Error fetching feature info.").openOn(map);
          });

      });


      // Initialize drawn items layer
      drawnItems = new L.FeatureGroup();
      drawnItems.options.zIndex = 2000; // Add this line
      map.addLayer(drawnItems);

      advancedToolsLayerGroup = new L.FeatureGroup().addTo(map);

      // Initialize measurement layer
      measurementLayer = new L.FeatureGroup();
      measurementLayer.options.zIndex = 2000; // Add this line
      map.addLayer(measurementLayer);

      // Advanced Tools Implementation
      let userLocationMarker = null;
      let elevationMarker = null;
      let intersectionMarkers = [];
      let bufferLayer = null;
      let legendControl = null;

      // Reverse Geocoding Function
      window.reverseGeocoding = function () {
        if (!map) {
          alert("Map not initialized");
          return;
        }

        // Change cursor
        map.getContainer().style.cursor = 'crosshair';

        // Add instruction control
        const instruction = L.control({ position: 'topright' });
        instruction.onAdd = function () {
          const div = L.DomUtil.create('div', 'instruction-control');
          div.innerHTML = 'Click on map to get address information';
          div.style.background = 'white';
          div.style.padding = '10px';
          div.style.borderRadius = '5px';
          div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
          return div;
        };
        instruction.addTo(map);

        // Handle map click
        function handleMapClick(e) {
          const { lat, lng } = e.latlng;

          // Create marker
          const marker = L.marker([lat, lng]).addTo(advancedToolsLayerGroup);

          // Fetch address data
          fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`, {
            headers: {
              'Accept': 'application/json',
              'User-Agent': 'Geoportal/1.0'
            }
          })
            .then(response => response.json())
            .then(data => {
              // Format address information
              const address = data.display_name || 'Address not found';
              const details = data.address || {};
              let popupContent = `
              <div class="reverse-geocoding-popup">
                <strong>Address:</strong><br>
                ${address}<br><br>
                <strong>Details:</strong><br>
            `;

              // Add address components if available
              if (details) {
                if (details.road) popupContent += `Road: ${details.road}<br>`;
                if (details.house_number) popupContent += `House Number: ${details.house_number}<br>`;
                if (details.suburb) popupContent += `Suburb: ${details.suburb}<br>`;
                if (details.city) popupContent += `City: ${details.city}<br>`;
                if (details.state) popupContent += `State: ${details.state}<br>`;
                if (details.country) popupContent += `Country: ${details.country}<br>`;
                if (details.postcode) popupContent += `Postcode: ${details.postcode}<br>`;
              }

              popupContent += '</div>';

              // Add popup to marker
              marker.bindPopup(popupContent).openPopup();
            })
            .catch(error => {
              console.error('Error fetching address:', error);
              marker.bindPopup('Error fetching address information').openPopup();
            });

          // Cleanup
          map.removeControl(instruction);
          map.off('click', handleMapClick);
          map.getContainer().style.cursor = '';
        }

        // Add click handler
        map.on('click', handleMapClick);
      };

      // Find My Location
      window.findMyLocation = function () {
        if (!navigator.geolocation) {
          alert('Geolocation is not supported by your browser');
          return;
        }

        // Remove existing location marker if any
        if (userLocationMarker) {
          advancedToolsLayerGroup.removeLayer(userLocationMarker);
        }

        // Show loading state
        const locationBtn = document.querySelector('[onclick="findMyLocation()"]');
        const originalText = locationBtn.innerHTML;
        locationBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Finding Location...';
        locationBtn.disabled = true;

        navigator.geolocation.getCurrentPosition(
          function (position) {
            const { latitude, longitude } = position.coords;

            // Create and add marker
            userLocationMarker = L.marker([latitude, longitude], {
              icon: L.divIcon({
                className: 'user-location-marker',
                html: '<i class="fas fa-location-arrow"></i>',
                iconSize: [24, 24]
              })
            }).addTo(advancedToolsLayerGroup);

            // Add popup with coordinates
            userLocationMarker.bindPopup(`
                        <div class="location-popup">
                            <strong>Your Location</strong><br>
                            Latitude: ${latitude.toFixed(6)}<br>
                            Longitude: ${longitude.toFixed(6)}
                        </div>
                    `).openPopup();

            // Center map on location
            map.setView([latitude, longitude], 15);

            // Reset button state
            locationBtn.innerHTML = originalText;
            locationBtn.disabled = false;
          },
          function (error) {
            alert('Error getting your location: ' + error.message);
            locationBtn.innerHTML = originalText;
            locationBtn.disabled = false;
          }
        );
      };

      // Get Point Elevation
      window.getPointElevation = function () {
        let clickHandler = null;

        // Remove existing elevation marker if any
        if (elevationMarker) {
          advancedToolsLayerGroup.removeLayer(elevationMarker);
        }

        // Show instructions
        const elevationBtn = document.querySelector('[onclick="getPointElevation()"]');
        const originalText = elevationBtn.innerHTML;
        elevationBtn.innerHTML = '<i class="fas fa-mouse-pointer"></i> Click on map...';
        elevationBtn.disabled = true;

        // Function to get elevation from coordinates
        async function getElevation(lat, lng) {
          try {
            const response = await fetch(`https://api.open-meteo.com/v1/elevation?latitude=${lat}&longitude=${lng}`);
            if (!response.ok) {
              console.error("Elevation API response not OK:", response.status, await response.text());
              return null;
            }
            const data = await response.json();
            if (typeof data.elevation === 'number') {
              return data.elevation;
            } else if (Array.isArray(data.elevation) && typeof data.elevation[0] === 'number') {
              return data.elevation[0];
            }
            console.error("Unexpected elevation data format:", data);
            return null;
          } catch (error) {
            console.error('Error fetching elevation:', error);
            return null;
          }
        }

        // Handle map click
        clickHandler = async function (e) {
          const { lat, lng } = e.latlng;

          // Create marker
          elevationMarker = L.marker([lat, lng], {
            icon: L.divIcon({
              className: 'elevation-marker',
              html: '<i class="fas fa-mountain"></i>',
              iconSize: [24, 24]
            })
          }).addTo(advancedToolsLayerGroup);

          // Get elevation
          const elevation = await getElevation(lat, lng);

          // Add popup with elevation
          elevationMarker.bindPopup(`
                    <div class="elevation-popup">
                        <strong>Elevation Data</strong><br>
                        Latitude: ${lat.toFixed(6)}<br>
                        Longitude: ${lng.toFixed(6)}<br>
                        Elevation: ${elevation !== null ? elevation.toFixed(2) + ' meters' : 'Not available'}
                    </div>
                `).openPopup();

          // Remove click handler
          map.off('click', clickHandler);

          // Reset button state
          elevationBtn.innerHTML = originalText;
          elevationBtn.disabled = false;
        };

        // Add click handler to map
        map.on('click', clickHandler);

        // Add cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'sub-btn';
        cancelBtn.innerHTML = '<i class="fas fa-times"></i> Cancel';
        cancelBtn.onclick = function () {
          map.off('click', clickHandler);
          elevationBtn.innerHTML = originalText;
          elevationBtn.disabled = false;
          this.remove();
        };
        document.querySelector('#advancedTools-dropdown .dropdown-section').appendChild(cancelBtn);
      };

      // Find Intersections
      window.findIntersections = function () {
        let points = [];
        let tempLine = null;
        let isDrawing = false;

        // Clear existing intersections
        intersectionMarkers.forEach(marker => advancedToolsLayerGroup.removeLayer(marker));
        intersectionMarkers = [];

        const intersectionBtn = document.querySelector('[onclick="findIntersections()"]');
        const originalText = intersectionBtn.innerHTML;
        intersectionBtn.innerHTML = '<i class="fas fa-mouse-pointer"></i> Draw lines...';
        intersectionBtn.disabled = true;

        // Handle map click
        function handleClick(e) {
          const { lat, lng } = e.latlng;
          points.push([lat, lng]);

          // Add point marker
          L.marker([lat, lng], {
            icon: L.divIcon({
              className: 'intersection-point',
              html: '<i class="fas fa-circle"></i>',
              iconSize: [8, 8]
            })
          }).addTo(advancedToolsLayerGroup);

          if (points.length === 1) {
            isDrawing = true;
          } else if (points.length === 2) {
            // Draw line between points
            if (tempLine) {
              advancedToolsLayerGroup.removeLayer(tempLine);
            }
            tempLine = L.polyline(points, {
              color: '#3498db',
              weight: 2,
              dashArray: '5, 5'
            }).addTo(advancedToolsLayerGroup);

            // Find intersections with existing lines
            findLineIntersections(points[0], points[1]);

            // Reset for next line
            points = [];
            isDrawing = false;
          }
        }

        // Find intersections with existing lines
        function findLineIntersections(start, end) {
          const lines = [];
          map.eachLayer(layer => {
            if (layer instanceof L.Polyline && layer !== tempLine) {
              lines.push(layer);
            }
          });

          lines.forEach(line => {
            const linePoints = line.getLatLngs();
            for (let i = 0; i < linePoints.length - 1; i++) {
              const intersection = findIntersection(
                start, end,
                linePoints[i], linePoints[i + 1]
              );
              if (intersection) {
                // Add intersection marker
                const marker = L.marker(intersection, {
                  icon: L.divIcon({
                    className: 'intersection-marker',
                    html: '<i class="fas fa-crosshairs"></i>',
                    iconSize: [24, 24]
                  })
                }).addTo(advancedToolsLayerGroup);

                marker.bindPopup(`
                                <div class="intersection-popup">
                                    <strong>Intersection Point</strong><br>
                                    Latitude: ${intersection.lat.toFixed(6)}<br>
                                    Longitude: ${intersection.lng.toFixed(6)}
                                </div>
                            `);

                intersectionMarkers.push(marker);
              }
            }
          });
        }

        // Calculate intersection point of two lines
        function findIntersection(p1, p2, p3, p4) {
          const x1 = p1[0], y1 = p1[1];
          const x2 = p2[0], y2 = p2[1];
          const x3 = p3.lat, y3 = p3.lng;
          const x4 = p4.lat, y4 = p4.lng;

          const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
          if (denominator === 0) return null; // Lines are parallel

          const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
          const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;

          if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
            return L.latLng(
              x1 + t * (x2 - x1),
              y1 + t * (y2 - y1)
            );
          }
          return null;
        }

        // Add click handler
        map.on('click', handleClick);

        // Add cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'sub-btn';
        cancelBtn.innerHTML = '<i class="fas fa-times"></i> Cancel';
        cancelBtn.onclick = function () {
          map.off('click', handleClick);
          if (tempLine) advancedToolsLayerGroup.removeLayer(tempLine);
          points = [];
          isDrawing = false;
          intersectionBtn.innerHTML = originalText;
          intersectionBtn.disabled = false;
          this.remove();
        };
        document.querySelector('#advancedTools-dropdown .dropdown-section').appendChild(cancelBtn);
      };
      ///////////////////////////////////////////////////////////////////////////////////////////////////
      // featuresInBuffer: array of GeoJSON features (from your buffer analysis)
      function showBufferTable(featuresInBuffer) {
        const panel = document.getElementById('bufferTablePanel');
        const thead = document.querySelector('#bufferTable thead');
        const tbody = document.querySelector('#bufferTable tbody');
        tbody.innerHTML = '';
        thead.innerHTML = '';

        if (!featuresInBuffer.length) {
          panel.style.display = 'none';
          return;
        }

        // Get all unique property keys from the first feature
        const keys = Object.keys(featuresInBuffer[0].properties);

        // Build table header
        const headerRow = document.createElement('tr');
        keys.forEach(key => {
          const th = document.createElement('th');
          th.textContent = key;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);

        // Build table rows
        featuresInBuffer.forEach(feature => {
          const p = feature.properties;
          const row = document.createElement('tr');
          keys.forEach(key => {
            const td = document.createElement('td');
            td.textContent = p[key] !== undefined ? p[key] : '';
            row.appendChild(td);
          });
          tbody.appendChild(row);
        });

        panel.style.display = 'block';
      }


      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


      // Buffer Analysis
      window.performBufferAnalysis = function () {
        let bufferRadius = 1000; // Default 1km
        let bufferLayer = null;
        let centerPoint = null;

        const bufferBtn = document.querySelector('[onclick="performBufferAnalysis()"]');
        const originalText = bufferBtn.innerHTML;
        bufferBtn.innerHTML = '<i class="fas fa-mouse-pointer"></i> Click center point...';
        bufferBtn.disabled = true;

        // Create radius input
        const radiusInput = document.createElement('div');
        radiusInput.className = 'buffer-input';
        radiusInput.innerHTML = `
    <input type="number" value="1000" min="100" max="10000" step="100" 
           onchange="updateBufferRadius(this.value)">
    <select onchange="updateBufferUnit(this.value)">
        <option value="meters">meters</option>
        <option value="kilometers">kilometers</option>
    </select>
  `;
        document.querySelector('#advancedTools-dropdown .dropdown-section').appendChild(radiusInput);

        // Update buffer radius
        window.updateBufferRadius = function (value) {
          bufferRadius = parseInt(value);
          if (centerPoint && bufferLayer) {
            bufferLayer.setRadius(bufferRadius);
          }
        };

        // Update buffer unit
        window.updateBufferUnit = function (unit) {
          const input = radiusInput.querySelector('input');
          const value = parseInt(input.value);
          if (unit === 'kilometers') {
            input.value = value * 1000;
            updateBufferRadius(value * 1000);
          } else {
            input.value = value / 1000;
            updateBufferRadius(value / 1000);
          }
        };

        // Handle map click
        function handleClick(e) {
          const { lat, lng } = e.latlng;
          centerPoint = [lat, lng];

          // Remove existing buffer
          if (bufferLayer) {
            advancedToolsLayerGroup.removeLayer(bufferLayer);
          }

          // Create buffer circle
          bufferLayer = L.circle(centerPoint, {
            radius: bufferRadius,
            color: '#3498db',
            fillColor: '#3498db',
            fillOpacity: 0.2,
            weight: 2
          }).addTo(advancedToolsLayerGroup);

          // --- WFS QUERY FOR FEATURES IN BUFFER ---
          // Get active WMS layer info
          let activeLayerName = null;
          let activeWmsUrl = null;
          for (const [name, layer] of Object.entries(overlayLayers)) {
            if (map.hasLayer(layer) && layer.wmsParams && layer.wmsParams.layers) {
              activeLayerName = layer.wmsParams.layers;
              activeWmsUrl = layer._url;
              break;
            }
          }

          if (!activeLayerName || !activeWmsUrl) {
            alert('No active WMS layer found.');
            map.off('click', handleClick);
            return;
          }

          // Build WFS request
          const wfsUrl = activeWmsUrl.replace('/wms', '/wfs');
          const params = [
            "service=WFS",
            "version=1.1.0",
            "request=GetFeature",
            `typeName=${encodeURIComponent(activeLayerName)}`,
            "outputFormat=application/json",
            "srsName=EPSG:4326"
          ].join("&");
          const proxyWfsUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(`${wfsUrl}?${params}`)}`;

          // Fetch features in buffer
          fetch(proxyWfsUrl, {
            headers: { 'ngrok-skip-browser-warning': 'true' }
          })
            .then(response => response.json())
            .then(data => {
              // Create turf.js buffer (in kilometers)
              const buffer = turf.circle([lng, lat], bufferRadius / 1000, { units: 'kilometers' });

              // Filter features inside buffer
              const featuresInBuffer = (data.features || []).filter(feature =>
                turf.booleanIntersects(buffer, feature)
              );

              // Show the table at the bottom
              showBufferTable(featuresInBuffer);

              // Remove the popup if it exists
              if (bufferLayer && bufferLayer.closePopup) {
                bufferLayer.closePopup();
              }
            })
            .catch(err => {
              alert('Error fetching features.');
              console.error(err);
            });

          // Remove click handler after one use
          map.off('click', handleClick);
        }

        // Add click handler
        map.on('click', handleClick);

        // Add cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'sub-btn';
        cancelBtn.innerHTML = '<i class="fas fa-times"></i> Cancel';
        cancelBtn.onclick = function () {
          map.off('click', handleClick);
          if (bufferLayer) advancedToolsLayerGroup.removeLayer(bufferLayer);
          bufferBtn.innerHTML = originalText;
          bufferBtn.disabled = false;
          radiusInput.remove();
          this.remove();
          // Hide the table when canceling
          document.getElementById('bufferTablePanel').style.display = 'none';
        };
        document.querySelector('#advancedTools-dropdown .dropdown-section').appendChild(cancelBtn);
      };

      // Show Legend
      window.toggleLegend = function () {
        if (legendControl) {
          map.removeControl(legendControl);
          legendControl = null;
          return;
        }

        legendControl = L.control({
          position: 'bottomright'
        });

        legendControl.onAdd = function (map) {
          const div = L.DomUtil.create('div', 'info legend');
          let content = '<h4>Map Legend</h4><div class="legend-content">';

          let hasWmsLegend = false;
          // Add WMS Layer Legends
          for (const layerName in overlayLayers) {
            if (map.hasLayer(overlayLayers[layerName])) {
              const info = wmsLegendInfo[layerName];
              if (info) {
                hasWmsLegend = true;
                content += `
                  <div class="legend-item" style="margin-bottom: 8px; display: block;">
                    <div style="display: flex; align-items: center;">
                      <div style="width: 20px; height: 3px; background-color: ${info.color}; margin-right: 10px; border-radius: 2px;"></div>
                      <span style="font-size: 12px; font-weight: bold;">${info.title}</span>
                    </div>
                    <p style="font-size: 11px; color: #666; margin: 2px 0 0 30px;">${info.description}</p>
                  </div>
                `;
              } else {
                // Show legend for active layers not in wmsLegendInfo
                hasWmsLegend = true;
                content += `
                  <div class="legend-item" style="margin-bottom: 8px; display: block;">
                    <div style="display: flex; align-items: center;">
                      <div style="width: 20px; height: 3px; background-color: #888; margin-right: 10px; border-radius: 2px;"></div>
                      <span style="font-size: 12px; font-weight: bold;">${layerName}</span>
                    </div>
                    <p style="font-size: 11px; color: #666; margin: 2px 0 0 30px;">No legend info available</p>
                  </div>
                `;
              }
            }
          }

          if (hasWmsLegend) {
            content += '<hr style="border: 0; border-top: 1px solid #eee; margin: 10px 0;">';
          }

          // Add Advanced Tools Legends
          content += `
            <div class="legend-item">
                <i class="fas fa-location-arrow"></i> Your Location
            </div>
            <div class="legend-item">
                <i class="fas fa-mountain"></i> Elevation Point
            </div>
            <div class="legend-item">
                <i class="fas fa-crosshairs"></i> Intersection
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(52, 152, 219, 0.2);"></div>
                Buffer Zone
            </div>
          `;

          content += '</div>'; // close legend-content
          div.innerHTML = content;
          return div;
        };

        legendControl.addTo(map);
      };

      // Clear Advanced Tools
      window.clearAdvancedTools = function () {
        if (advancedToolsLayerGroup) {
          advancedToolsLayerGroup.clearLayers();
        }
        if (legendControl) {
          map.removeControl(legendControl);
          legendControl = null;
        }
        // Reset local tracking variables
        userLocationMarker = null;
        elevationMarker = null;
        intersectionMarkers = [];
        bufferLayer = null;
      };

      // Add styles for the new features
      const style = document.createElement('style');
      style.textContent = `
            .user-location-marker i,
            .elevation-marker i,
            .intersection-marker i {
                color: #3498db;
                font-size: 20px;
                text-shadow: 2px 2px 3px rgba(0,0,0,0.3);
            }

            .intersection-point i {
                color: #e74c3c;
                font-size: 8px;
            }

            .buffer-input {
                padding: 8px;
                display: flex;
                gap: 8px;
            }

            .buffer-input input {
                width: 80px;
                padding: 4px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }

            .buffer-input select {
                padding: 4px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }

            .legend {
                background: white;
                padding: 10px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }

            .legend h4 {
                margin: 0 0 8px 0;
                font-size: 14px;
                color: #2c3e50;
            }

            .legend-content {
                font-size: 12px;
            }

            .legend-item {
                display: flex;
                align-items: center;
                margin: 4px 0;
            }

            .legend-item i {
                margin-right: 8px;
                width: 16px;
                text-align: center;
            }

            .legend-color {
                width: 16px;
                height: 16px;
                margin-right: 8px;
                border: 1px solid #3498db;
            }
        `;
      document.head.appendChild(style);

      // Define basemaps
      basemaps = {
        osm: L.tileLayer(
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          {
            attribution: "¬© OpenStreetMap contributors",
            zIndex: 1,
          }
        ),
        satellite: L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          {
            attribution: "¬© Esri",
            zIndex: 1,
          }
        ),
        terrain: L.tileLayer(
          "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
          {
            attribution: "¬© OpenTopoMap",
            zIndex: 1,
          }
        ),
        dark: L.tileLayer(
          "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
          {
            attribution: "¬© CARTO",
            zIndex: 1,
          }
        ),
        esri_topo: L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
          {
            attribution: "¬© Esri",
            zIndex: 1,
          }
        ),
        esri_ocean: L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}",
          {
            attribution: "¬© Esri",
            zIndex: 1,
          }
        ),
        google_hybrid: L.tileLayer(
          "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}",
          {
            attribution: "¬© Google",
            zIndex: 1,
          }
        ),
      };

      // Add default basemap
      currentBasemap = basemaps.osm;
      currentBasemap.addTo(map);

      // Initialize WMS layers
      initializeWMSLayers();

      // Setup draw controls
      setupDrawControls();

      // Setup event listeners
      setupEventListeners();

      // Initialize geocoder
      initializeGeocoder();

      // Update layer list
      updateLayerList();
    }

    // Setup drawing controls
    function setupDrawControls() {
      const drawPluginOptions = {
        position: "topleft",
        draw: {
          polygon: {
            allowIntersection: false,
            drawError: {
              color: "#e1e100",
              message: "<strong>Oh snap!<strong> you can't draw that!",
            },
            shapeOptions: {
              color: "#97009c",
            },
          },
          polyline: {
            shapeOptions: {
              color: "#f357a1",
              weight: 10,
            },
          },
          rect: {
            shapeOptions: {
              clickable: false,
            },
          },
          circle: false,
          marker: true,
          circlemarker: false,
        },
        edit: {
          featureGroup: drawnItems,
          remove: true,
        },
      };

      drawControl = new L.Control.Draw(drawPluginOptions);
      map.addControl(drawControl);
    }

    // Setup event listeners
    function setupEventListeners() {
      // Mouse move event for coordinates
      map.on("mousemove", function (e) {
        const coords = document.getElementById("coordinates");
        coords.innerHTML = `Lat: ${e.latlng.lat.toFixed(
          6
        )}, Lng: ${e.latlng.lng.toFixed(6)}`;
      });

      // Draw events
      map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;

        if (isMeasuring && measurementType) {
          // This is a measurement
          measurementLayer.addLayer(layer);

          let measurement;
          let popupContent;

          if (measurementType === "distance" && layer instanceof L.Polyline) {
            const latlngs = layer.getLatLngs();
            measurement = calculateDistance(latlngs);
            popupContent = `<b>Distance:</b><br>${formatMeasurement(
              measurement,
              "distance"
            )}`;
          } else if (
            measurementType === "area" &&
            layer instanceof L.Polygon
          ) {
            const latlngs = layer.getLatLngs()[0];
            measurement = calculateArea(latlngs);
            popupContent = `<b>Area:</b><br>${formatMeasurement(
              measurement,
              "area"
            )}`;
          }

          if (popupContent) {
            layer.bindPopup(popupContent).openPopup();
          }

          // Reset measurement state
          isMeasuring = false;
          measurementType = null;

          // Remove active state from measurement buttons
          document
            .querySelectorAll("#measurements-content .sub-btn")
            .forEach((btn) => {
              btn.classList.remove("active");
            });
        } else {
          // Regular drawing
          drawnItems.addLayer(layer);
        }

        updateLayerList();
      });

      map.on(L.Draw.Event.EDITED, function (e) {
        updateLayerList();
      });

      map.on(L.Draw.Event.DELETED, function (e) {
        updateLayerList();
      });

      // WMS layer error handling
      map.on("tileerror", function (e) {
        console.warn("WMS Layer loading error:", e);
      });
    }

    // Initialize geocoder
    function initializeGeocoder() {
      const geocoder = L.Control.geocoder({
        defaultMarkGeocode: false,
      }).on("markgeocode", function (e) {
        const bbox = e.geocode.bbox;
        const poly = L.polygon([
          bbox.getSouthEast(),
          bbox.getNorthEast(),
          bbox.getNorthWest(),
          bbox.getSouthWest(),
        ]).addTo(map);
        map.fitBounds(poly.getBounds());
      });
    }

    // Toggle section function
    function toggleDropdown(dropdownId, event) {
      event.stopPropagation();
      const dropdown = document.getElementById(dropdownId + "-dropdown");
      const allDropdowns = document.querySelectorAll(".dropdown-content");

      allDropdowns.forEach((d) => {
        if (d !== dropdown) {
          d.classList.remove("show");
        }
      });

      dropdown.classList.toggle("show");
    }

    // Initialize WMS layers
    function initializeWMSLayers() {
      initializeScaleDependentLayers();

      const layerSelector = document.getElementById("layerSelector");

      layerSelector.addEventListener("change", function () {
        const layerName = this.value;
        if (currentWMSLayer) {
          map.removeLayer(currentWMSLayer);
          currentWMSLayer = null;
        }

        // Add the correct WMS layer based on selection
        let wmsOptions = {
          url: "",
          layer: "",
          bounds: [
            [15.5, 72.5],
            [35.5, 97.5],
          ], // Default bounds (India)
        };

        switch (layerName) {
          case "drone_based_contour":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:DRONE_Based_Contour_1M_Tuljabhavani_Complex_Surrounding";
            break;
          case "drone_based_masterplan":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:DRONE_Based_Master_Plan_Tuljapur";
            break;
          case "district_boundary":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:District_Project";
            break;
          case "division_boundary":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Division_Project";
            break;
          case "hq_tal_dist_div":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:HQ_TAL_DIST_DIV_Project";
            break;
          case "india_boundary":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:India_Project";
            break;
          case "maharashtra_boundary":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Maha_State_Project";
            break;
          case "monument_locations":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Monument_Locations";
            break;
          case "taluka_boundary":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Taluka_Project";
            break;
          case "tuljabhavani_temple_complex":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Tuljabhavani_Temple_Complex_Boundary";
            break;
          case "tuljabhavani_temple_trust":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Tuljabhavani_Temple_Trust_Acquisation_Area";
            break;
          case "tuljapur_municipal_council":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Tuljapur_Municipal_Council";
            break;
          case "tuljapur_taluka":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Tuljapur_Municipal_Council";
            break;
          case "tuljapur_village":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Tuljapur_Village";
            break;
          case "village_boundary":
            wmsOptions.url = `${GEOSERVER_URL}/allshapefiles/wms`;
            wmsOptions.layer = "allshapefiles:Village_Project";
            break;
          default:
            wmsOptions = null;
        }

        if (wmsOptions && wmsOptions.layer) {
          currentWMSLayer = L.tileLayer
            .wms(wmsOptions.url, {
              layers: wmsOptions.layer,
              format: "image/png",
              transparent: true,
              version: "1.1.0",
              attribution: "GeoServer Web Map Service",
              crs: L.CRS.EPSG3857,
              maxZoom: 22,
              minZoom: 0,
              opacity: 0.8,
              zIndex: 500,
            })
            .addTo(map);

          overlayLayers[layerName] = currentWMSLayer;

          // Center and zoom after adding the layer
          const zoom = wmsLayerZoomLevels[layerName];
          if (zoom) {
            const regionalLayers = ['india_boundary', 'maharashtra_boundary', 'division_boundary', 'district_boundary', 'village_boundary'];
            let centerLat, centerLng;

            if (regionalLayers.includes(layerName)) {
              centerLat = 19.911384;
              centerLng = 77.541504;
            } else {
              centerLat = 18.012437;
              centerLng = 76.066005;
            }

            setTimeout(() => {
              map.setView([centerLat, centerLng], zoom);
            }, 300); // Delay to ensure layer is added before zooming
          }

          updateLayerList();
          updateLegend(layerName);

          // ADD THIS LINE to trigger the proxy request for labels:
          showWMSLabels(wmsOptions.layer, wmsOptions.url, layerName);
        }
      });
      // After you add the new WMS layer:
      if (infoToolActive) {
        // Remove old vector layer if present
        if (contourVectorLayer) {
          map.removeLayer(contourVectorLayer);
          contourVectorLayer = null;
        }
        // Load new features for the new layer
        showAllFeatures();
      }
    }

    ///////////////////////////////////////////////////////NAVBAR EXPNASION///////////////////////////////
    function toggleNavbarExpansion() {
      const navbar = document.getElementById("navbar");
      const navbarContent = document.getElementById("navbarContent");
      const overflowToggle = document.querySelector(".navbar-overflow-toggle");

      if (!navbar || !navbarContent) return;

      isNavbarExpanded = !isNavbarExpanded;

      navbar.classList.toggle("expanded");
      navbarContent.classList.toggle("expanded");

      if (overflowToggle) {
        overflowToggle.classList.toggle("active");
        const toggleIcon = overflowToggle.querySelector("i");
        if (toggleIcon) {
          toggleIcon.classList.toggle("fa-chevron-down");
          toggleIcon.classList.toggle("fa-chevron-up");
        }
      }
    }

    // Initialize navbar
    document.addEventListener("DOMContentLoaded", function () {
      const toggle = document.getElementById("navbarToggle");
      if (toggle) {
        toggle.addEventListener("click", toggleNavbarExpansion);
      }
    });

    function positionDropdowns() {
      const buttons = document.querySelectorAll(".feature-btn");
      const dropdowns = document.querySelectorAll(".dropdown-content");

      buttons.forEach((button, index) => {
        const dropdown = dropdowns[index];
        if (!dropdown) return;

        const rect = button.getBoundingClientRect();

        dropdown.style.position = "fixed";
        dropdown.style.top = `${rect.bottom + window.scrollY}px`;
        dropdown.style.left = `${rect.left + window.scrollX}px`;
        dropdown.style.width = `${Math.max(rect.width, 200)}px`;
        dropdown.style.zIndex = "9999";
      });
    }

    function positionDropdownFixed(dropdown, button) {
      const buttonRect = button.getBoundingClientRect();
      const dropdownHeight = dropdown.offsetHeight;
      const viewportHeight = window.innerHeight;

      // Calculate position
      let top = buttonRect.bottom + 5; // 5px gap below button

      // Check if dropdown would go below viewport
      if (top + dropdownHeight > viewportHeight) {
        top = buttonRect.top - dropdownHeight - 5; // Position above button
      }

      // Set fixed positioning
      dropdown.style.position = "fixed";
      dropdown.style.top = top + "px";
      dropdown.style.left = buttonRect.left + "px";
      dropdown.style.width = Math.max(200, buttonRect.width) + "px"; // Minimum width of 200px
      dropdown.style.zIndex = "9999";
    }

    // Reset dropdown positioning when navbar collapses
    function resetDropdownPositioning() {
      document.querySelectorAll(".dropdown-content").forEach((dropdown) => {
        dropdown.style.position = "";
        dropdown.style.top = "";
        dropdown.style.left = "";
        dropdown.style.width = "";
        dropdown.style.zIndex = "";
      });
    }

    // Auto-detect if overflow toggle is needed
    function checkNavbarOverflow() {
      const navbarContent = document.getElementById("navbarContent");
      const overflowToggle = document.querySelector(".navbar-overflow-toggle");

      if (!navbarContent || !overflowToggle) return;

      let totalWidth = 0;
      const groups = navbarContent.querySelectorAll(".navbar-group");

      groups.forEach((group) => {
        totalWidth += group.offsetWidth + 15; // Include gap
      });

      const availableWidth = navbarContent.offsetWidth;

      if (totalWidth > availableWidth) {
        overflowToggle.classList.remove("hidden");
      } else {
        overflowToggle.classList.add("hidden");
        if (isNavbarExpanded) toggleNavbarExpansion(); // Collapse if not needed
      }
    }

    function initializeNavbar() {
      const overflowToggle = document.querySelector(".navbar-overflow-toggle");
      const navbar = document.getElementById("navbar");

      // Check if required elements exist
      if (!overflowToggle) {
        console.warn("Element with class 'navbar-overflow-toggle' not found");
        return;
      }

      if (!navbar) {
        console.warn("Element with ID 'navbar' not found");
        return;
      }

      console.log("Navbar elements found successfully");

      // Attach click event to overflow toggle button
      overflowToggle.addEventListener("click", toggleNavbarExpansion);

      // Check overflow on window resize
      window.addEventListener("resize", checkNavbarOverflow);

      // Initial check with delay to ensure DOM is ready
      setTimeout(checkNavbarOverflow, 500);

      // Close expanded navbar when clicking outside
      document.addEventListener("click", function (event) {
        if (isNavbarExpanded && !navbar.contains(event.target)) {
          toggleNavbarExpansion();
        }
      });

      // Keyboard accessibility for overflow toggle
      overflowToggle.addEventListener("keydown", function (event) {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          toggleNavbarExpansion();
        }
      });
    }

    // Close dropdowns when clicking outside
    document.addEventListener("click", function (event) {
      const dropdowns = document.querySelectorAll(".dropdown-content");
      dropdowns.forEach((dropdown) => {
        if (!dropdown.contains(event.target) && !event.target.closest(".feature-btn")) {
          dropdown.classList.remove("show");
        }
      });
    });

    // Initialize everything when DOM is loaded
    document.addEventListener("DOMContentLoaded", function () {
      console.log("DOM loaded, initializing navbar...");
      initializeNavbar();
    });
    /////////////////////////////////////////////////////////NAV END//////////////////////////////////////

    /////////////////////////////////////////////////NEW SECTION///////////////////////////////////////////////////
    function initializeScaleDependentLayers() {
      // Create a layer group with all administrative boundaries
      const wmsLayerNames = {
        "allshapefiles:India_Project": "India Boundary",
        "allshapefiles:Maha_State_Project": "Maharashtra Boundary",
        "allshapefiles:Division_Project": "Division Boundary",
        "allshapefiles:District_Project": "District Boundary",
        "allshapefiles:Taluka_Project": "Taluka Boundary",
        "allshapefiles:Village_Project": "Village Boundary"
      };

      const administrativeBoundaries = L.tileLayer.wms(
        `${GEOSERVER_URL}/allshapefiles/wms`, {
        layers: Object.keys(wmsLayerNames).join(','),
        format: "image/png",
        transparent: true,
        version: "1.1.0",
        attribution: "GeoServer Web Map Service",
        crs: L.CRS.EPSG3857,
        maxZoom: 22,
        minZoom: 0,
        opacity: 0.8,
        zIndex: 1000,
      }
      );
      // administrativeBoundaries.addTo(map); // Removed to prevent auto-loading

      // Store in overlay layers
      overlayLayers["Administrative Boundaries"] = administrativeBoundaries;
    }

    // Alternative: Individual layers with client-side zoom control


    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Update legend
    function updateLegend(layerName) {
      const legendContainer = document.getElementById("legendContainer");
      const legendContent = document.getElementById("legendContent");

      if (!layerName) {
        legendContainer.style.display = "none";
        return;
      }

      legendContainer.style.display = "block";

      // Create legend based on layer type
      const info = wmsLegendInfo[layerName];
      if (info) {
        legendContent.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 8px;">
              <div style="width: 20px; height: 3px; background-color: ${info.color}; margin-right: 10px; border-radius: 2px;"></div>
              <span style="font-size: 12px; font-weight: bold;">${info.title}</span>
            </div>
            <p style="font-size: 11px; color: #666; margin: 0;">${info.description}</p>
          `;
      } else {
        legendContent.innerHTML = '';
      }
    }
    function changeBasemap(basemapType) {
      // Remove current basemap
      if (typeof currentBasemap !== "undefined" && map.hasLayer(currentBasemap)) {
        map.removeLayer(currentBasemap);
      }

      // Add new basemap
      map.addLayer(basemaps[basemapType]);
      currentBasemap = basemaps[basemapType];

      // Update UI
      document.querySelectorAll(".basemap-item").forEach((item) => {
        item.classList.remove("active");
      });
      document
        .querySelector(`[data-basemap="${basemapType}"]`)
        .classList.add("active");
    }

    // Select draw tool function
    function selectDrawTool(tool) {
      // Clear any active drawing states
      if (currentDrawTool) {
        document.querySelectorAll(".sub-btn").forEach((btn) => {
          btn.classList.remove("active");
        });
      }

      // Set active tool
      currentDrawTool = tool;
      event.currentTarget.classList.add("active");

      // Enable appropriate drawing mode
      switch (tool) {
        case "point":
          new L.Draw.Marker(map, drawControl.options.draw.marker).enable();
          break;
        case "polyline":
          new L.Draw.Polyline(
            map,
            drawControl.options.draw.polyline
          ).enable();
          break;
        case "polygon":
          new L.Draw.Polygon(map, drawControl.options.draw.polygon).enable();
          break;
        case "rectangle":
          new L.Draw.Rectangle(map, drawControl.options.draw.rect).enable();
          break;
        case "circle":
          new L.Draw.Circle(map, drawControl.options.draw.circle).enable();
          break;
        case "edit":
          new L.EditToolbar.Edit(map, {
            featureGroup: drawnItems,
          }).enable();
          break;
        case "delete":
          new L.EditToolbar.Delete(map, {
            featureGroup: drawnItems,
          }).enable();
          break;
      }
    }

    // Clear all drawings
    function clearAllDrawings() {
      drawnItems.clearLayers();
      updateLayerList();
    }

    // Start measurement
    function startMeasurement(type) {
      // Clear any previous measurement state
      clearMeasurements();
      isMeasuring = true;
      measurementType = type;

      // Remove active state from other buttons
      document
        .querySelectorAll("#measurements-dropdown .sub-btn")
        .forEach((btn) => {
          btn.classList.remove("active");
        });

      // Find and set active state for current button
      const activeButton = document.querySelector(
        `#measurements-dropdown .sub-btn[onclick="startMeasurement('${type}')"]`
      );
      if (activeButton) {
        activeButton.classList.add("active");
      }

      if (type === "distance") {
        new L.Draw.Polyline(map, {
          shapeOptions: {
            color: "#ff0000",
            weight: 3,
          },
        }).enable();
      } else if (type === "area") {
        new L.Draw.Polygon(map, {
          shapeOptions: {
            color: "#ff0000",
            weight: 3,
            fillOpacity: 0.2,
          },
        }).enable();
      }
    }

    function calculateArea(latlngs) {
      let area = 0;
      if (latlngs.length > 2) {
        for (let i = 0; i < latlngs.length; i++) {
          let j = (i + 1) % latlngs.length;
          area += latlngs[i].lat * latlngs[j].lng;
          area -= latlngs[j].lat * latlngs[i].lng;
        }
        area = Math.abs(area) / 2;
      }
      return area * 111319.9 * 111319.9;
    }

    function calculateDistance(latlngs) {
      let totalDistance = 0;
      for (let i = 0; i < latlngs.length - 1; i++) {
        totalDistance += map.distance(latlngs[i], latlngs[i + 1]);
      }
      return totalDistance;
    }

    function formatMeasurement(value, type) {
      if (type === "distance") {
        if (currentUnit === "imperial") {
          // meters to miles/feet
          if (value >= 1609.34) {
            return (value / 1609.34).toFixed(2) + " mi";
          } else {
            return (value * 3.28084).toFixed(2) + " ft";
          }
        } else {
          // metric
          if (value >= 1000) {
            return (value / 1000).toFixed(2) + " km";
          } else {
            return value.toFixed(2) + " m";
          }
        }
      } else if (type === "area") {
        if (currentUnit === "imperial") {
          // m¬≤ to mi¬≤/ft¬≤
          if (value >= 2589988.11) {
            return (value / 2589988.11).toFixed(2) + " mi¬≤";
          } else {
            return (value * 10.7639).toFixed(2) + " ft¬≤";
          }
        } else {
          // metric
          if (value >= 1000000) {
            return (value / 1000000).toFixed(2) + " km¬≤";
          } else if (value >= 10000) {
            return (value / 10000).toFixed(2) + " hectares";
          } else {
            return value.toFixed(2) + " m¬≤";
          }
        }
      }
      return value.toString();
    }

    // Clear measurements
    function clearMeasurements() {
      measurementLayer.clearLayers();
      isMeasuring = false;
      measurementType = null;

      // Remove active state from all measurement buttons
      document
        .querySelectorAll("#measurements-dropdown .sub-btn")
        .forEach((btn) => {
          btn.classList.remove("active");
        });
    }

    // Handle file upload
    function handleFileUpload(event) {
      const files = event.target.files;
      console.log("Files selected:", files.length);

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const fileName = file.name.toLowerCase();
        console.log("Processing file:", fileName, "Size:", file.size);

        if (fileName.endsWith(".zip")) {
          // Handle shapefile (ZIP)
          handleShapefileUpload(file);
        } else if (
          fileName.endsWith(".geojson") ||
          fileName.endsWith(".json")
        ) {
          // Handle GeoJSON
          handleGeoJSONUpload(file);
        } else if (fileName.endsWith(".kml")) {
          alert(
            "KML support coming soon. Please convert to GeoJSON for now."
          );
        } else if (fileName.endsWith(".gpx")) {
          alert(
            "GPX support coming soon. Please convert to GeoJSON for now."
          );
        } else {
          alert("Unsupported file format: " + file.name);
        }
      }

      // Clear the input so the same file can be uploaded again
      event.target.value = "";
    }

    function handleGeoJSONUpload(file) {
      const reader = new FileReader();

      reader.onload = function (e) {
        try {
          const geojsonData = JSON.parse(e.target.result);
          const layer = L.geoJSON(geojsonData, {
            style: {
              color: "#3388ff",
              weight: 2,
              opacity: 0.8,
              fillOpacity: 0.3,
              zIndex: 2000
            },
            onEachFeature: function (feature, layer) {
              if (layer.setZIndex) layer.setZIndex(2000);
              layer.on('click', function (e) {
                if (infoToolActive) {
                  showFeatureInSidebar(feature);
                  e.originalEvent.preventDefault();
                  e.originalEvent.stopPropagation();
                }
              });
              // Optionally, keep popup for non-info mode
              if (feature.properties) {
                let popupContent = "<div>";
                Object.keys(feature.properties).forEach((key) => {
                  popupContent += `<b>${key}:</b> ${feature.properties[key]}<br>`;
                });
                popupContent += "</div>";
                layer.bindPopup(popupContent);
              }
            },
          }).addTo(map);

          overlayLayers[file.name] = layer;
          map.fitBounds(layer.getBounds());
          updateLayerList();

          alert(`Successfully loaded: ${file.name}`);
        } catch (error) {
          alert("Error loading GeoJSON file: " + file.name);
          console.error("GeoJSON load error:", error);
        }
      };

      reader.readAsText(file);
    }

    // 8. Add new function to handle shapefile uploads:
    function handleShapefileUpload(file) {
      console.log("Loading shapefile:", file.name);

      // Check if shp library is loaded
      if (typeof shp === "undefined") {
        console.error("Shapefile library not loaded");
        alert(
          "Shapefile library not loaded. Please refresh the page and try again."
        );
        return;
      }

      const reader = new FileReader();

      reader.onload = function (e) {
        console.log("File read complete, parsing...");
        try {
          // Use shp library to parse the shapefile
          shp(e.target.result)
            .then(function (geojson) {
              console.log("Shapefile parsed successfully:", geojson);

              // Check if geojson has features
              if (
                !geojson ||
                !geojson.features ||
                geojson.features.length === 0
              ) {
                alert("No features found in shapefile: " + file.name);
                return;
              }

              // Enhanced debugging for coordinate system
              console.log("Number of features:", geojson.features.length);
              console.log(
                "First feature geometry type:",
                geojson.features[0].geometry.type
              );
              console.log(
                "First feature coordinates:",
                geojson.features[0].geometry.coordinates
              );

              // Check the actual coordinate values for CRS detection
              let coords = geojson.features[0].geometry.coordinates;
              let sampleLng, sampleLat;

              if (geojson.features[0].geometry.type === "Point") {
                sampleLng = coords[0];
                sampleLat = coords[1];
              } else if (geojson.features[0].geometry.type === "Polygon") {
                console.log("First polygon ring:", coords[0]);
                console.log("First coordinate pair:", coords[0][0]);
                sampleLng = coords[0][0][0];
                sampleLat = coords[0][0][1];
              } else if (
                geojson.features[0].geometry.type === "MultiPolygon"
              ) {
                console.log("First multipolygon:", coords[0][0]);
                console.log("First coordinate pair:", coords[0][0][0]);
                sampleLng = coords[0][0][0][0];
                sampleLat = coords[0][0][0][1];
              } else if (geojson.features[0].geometry.type === "LineString") {
                sampleLng = coords[0][0];
                sampleLat = coords[0][1];
              } else if (
                geojson.features[0].geometry.type === "MultiLineString"
              ) {
                sampleLng = coords[0][0][0];
                sampleLat = coords[0][0][1];
              }

              console.log(
                "Sample coordinates - Lng:",
                sampleLng,
                "Lat:",
                sampleLat
              );

              // Check if coordinates are outside normal lat/lng ranges
              if (Math.abs(sampleLat) > 90 || Math.abs(sampleLng) > 180) {
                console.log("Attempting to reproject coordinates...");

                // Check if proj4 library is available
                if (typeof proj4 === "undefined") {
                  console.warn(
                    "Coordinates appear to be in a projected coordinate system!"
                  );
                  console.warn(
                    "Latitude should be between -90 and 90, Longitude between -180 and 180"
                  );
                  console.warn(
                    "Current values - Lat:",
                    sampleLat,
                    "Lng:",
                    sampleLng
                  );
                  alert(
                    "Warning: The shapefile appears to use a projected coordinate system (like UTM). It needs to be in WGS84 (EPSG:4326) to display properly on the map. Please reproject your shapefile to WGS84."
                  );
                  return;
                }

                // Define source projection as EPSG:3395 (World Mercator)
                let sourceProj =
                  "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs";
                let targetProj = "+proj=longlat +datum=WGS84 +no_defs";

                try {
                  // Reproject all coordinates in the GeoJSON
                  geojson.features.forEach((feature) => {
                    if (feature.geometry.type === "Point") {
                      feature.geometry.coordinates = proj4(
                        sourceProj,
                        targetProj,
                        feature.geometry.coordinates
                      );
                    } else if (feature.geometry.type === "Polygon") {
                      feature.geometry.coordinates =
                        feature.geometry.coordinates.map((ring) =>
                          ring.map((coord) =>
                            proj4(sourceProj, targetProj, [
                              coord[0],
                              coord[1],
                            ])
                          )
                        );
                    } else if (feature.geometry.type === "MultiPolygon") {
                      feature.geometry.coordinates =
                        feature.geometry.coordinates.map((polygon) =>
                          polygon.map((ring) =>
                            ring.map((coord) =>
                              proj4(sourceProj, targetProj, [
                                coord[0],
                                coord[1],
                              ])
                            )
                          )
                        );
                    } else if (feature.geometry.type === "LineString") {
                      feature.geometry.coordinates =
                        feature.geometry.coordinates.map((coord) =>
                          proj4(sourceProj, targetProj, [coord[0], coord[1]])
                        );
                    } else if (feature.geometry.type === "MultiLineString") {
                      feature.geometry.coordinates =
                        feature.geometry.coordinates.map((line) =>
                          line.map((coord) =>
                            proj4(sourceProj, targetProj, [
                              coord[0],
                              coord[1],
                            ])
                          )
                        );
                    }
                  });

                  // Recalculate sample coordinates after reprojection
                  coords = geojson.features[0].geometry.coordinates;
                  if (geojson.features[0].geometry.type === "Point") {
                    sampleLng = coords[0];
                    sampleLat = coords[1];
                  } else if (
                    geojson.features[0].geometry.type === "Polygon"
                  ) {
                    sampleLng = coords[0][0][0];
                    sampleLat = coords[0][0][1];
                  } else if (
                    geojson.features[0].geometry.type === "MultiPolygon"
                  ) {
                    sampleLng = coords[0][0][0][0];
                    sampleLat = coords[0][0][0][1];
                  } else if (
                    geojson.features[0].geometry.type === "LineString"
                  ) {
                    sampleLng = coords[0][0];
                    sampleLat = coords[0][1];
                  } else if (
                    geojson.features[0].geometry.type === "MultiLineString"
                  ) {
                    sampleLng = coords[0][0][0];
                    sampleLat = coords[0][0][1];
                  }

                  console.log("Reprojection completed");
                  console.log(
                    "New sample coordinates - Lng:",
                    sampleLng,
                    "Lat:",
                    sampleLat
                  );
                } catch (projError) {
                  console.error("Projection failed:", projError);
                  alert(
                    "Could not automatically reproject the shapefile. Please convert to WGS84 manually."
                  );
                  return;
                }
              }

              // Create the layer with boundary-only styling
              const layer = L.geoJSON(geojson, {
                style: {
                  color: "#ff0000", // Red boundary
                  weight: 2, // Moderate line thickness
                  opacity: 1,
                  fillOpacity: 0, // No fill - boundary only
                  zIndex: 2000
                },
                onEachFeature: function (feature, layer) {
                  // Add click event for debugging
                  layer.on("click", function (e) {
                    console.log("Feature clicked!", feature.properties);
                    console.log("Click coordinates:", e.latlng);
                  });

                  if (feature.properties) {
                    let popupContent =
                      '<div style="max-height: 200px; overflow-y: auto;">';
                    Object.keys(feature.properties).forEach((key) => {
                      if (
                        feature.properties[key] !== null &&
                        feature.properties[key] !== undefined
                      ) {
                        popupContent += `<b>${key}:</b> ${feature.properties[key]}<br>`;
                      }
                    });
                    popupContent += "</div>";
                    layer.bindPopup(popupContent);
                  }
                },
              });

              // Add to map with debugging
              console.log("Adding layer to map...");
              layer.addTo(map);
              if (layer.setZIndex) layer.setZIndex(2000);
              console.log(
                "Layer added. Layer count on map:",
                Object.keys(map._layers).length
              );

              overlayLayers[file.name] = layer;

              // Enhanced bounds fitting with more debugging
              try {
                const bounds = layer.getBounds();
                console.log("Layer bounds:", bounds);
                console.log(
                  "Bounds details - SW:",
                  bounds.getSouthWest(),
                  "NE:",
                  bounds.getNorthEast()
                );
                console.log("Current map bounds:", map.getBounds());
                console.log("Current map center:", map.getCenter());
                console.log("Current map zoom:", map.getZoom());

                if (bounds && bounds.isValid()) {
                  // If the bounds are not fully visible, fit them; otherwise, just pan to center
                  if (!map.getBounds().contains(bounds)) {
                    map.fitBounds(bounds, { padding: [50, 50] });
                  } else {
                    map.panTo(bounds.getCenter());
                  }
                  setTimeout(() => {
                    console.log(
                      "After setView - Center:",
                      map.getCenter(),
                      "Zoom:",
                      map.getZoom()
                    );
                  }, 100);
                } else {
                  console.warn(
                    "Invalid bounds, trying manual center calculation"
                  );
                  if (
                    sampleLat &&
                    sampleLng &&
                    Math.abs(sampleLat) <= 90 &&
                    Math.abs(sampleLng) <= 180
                  ) {
                    console.log("Setting view to sample coordinates:", [
                      sampleLat,
                      sampleLng,
                    ]);
                    map.setView([sampleLat, sampleLng], map.getZoom());
                  } else {
                    console.error(
                      "Cannot determine valid center coordinates"
                    );
                  }
                }
              } catch (boundsError) {
                console.error("Error fitting bounds:", boundsError);
                if (
                  sampleLat &&
                  sampleLng &&
                  Math.abs(sampleLat) <= 90 &&
                  Math.abs(sampleLng) <= 180
                ) {
                  console.log("Fallback: centering on sample coordinates");
                  map.setView([sampleLat, sampleLng], map.getZoom());
                }
              }

              // Force map refresh
              setTimeout(() => {
                map.invalidateSize();
                console.log("Map size invalidated and refreshed");
              }, 200);

              updateLayerList();
              alert(
                `Successfully loaded shapefile: ${file.name}\nFeatures: ${geojson.features.length
                }\nCoordinates: ${sampleLat.toFixed(6)}, ${sampleLng.toFixed(
                  6
                )}`
              );
            })
            .catch(function (error) {
              console.error("Shapefile parse error:", error);
              alert(
                "Error parsing shapefile: " +
                file.name +
                "\nMake sure it contains all required files (.shp, .shx, .dbf, .prj)\nError details: " +
                error.message
              );
            });
        } catch (error) {
          console.error("Shapefile load error:", error);
          alert(
            "Error loading shapefile: " +
            file.name +
            "\nError: " +
            error.message
          );
        }
      };

      reader.onerror = function (error) {
        console.error("File read error:", error);
        alert("Error reading file: " + file.name);
      };

      reader.readAsArrayBuffer(file);
    }

    // Perform search
    function performSearch() {
      const query = document.getElementById("searchInput").value;
      if (!query) return;

      // Using Nominatim for geocoding
      fetch(
        `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
          query
        )}`
      )
        .then((response) => response.json())
        .then((data) => {
          if (data.length > 0) {
            const result = data[0];
            const lat = parseFloat(result.lat);
            const lon = parseFloat(result.lon);

            map.setView([lat, lon], 13);
            L.marker([lat, lon])
              .addTo(map)
              .bindPopup(result.display_name)
              .openPopup();
          } else {
            alert("No results found for: " + query);
          }
        })
        .catch((error) => {
          console.error("Search error:", error);
          alert("Search failed. Please try again.");
        });
    }

    // Update layer list
    function updateLayerList() {
      const layerList = document.getElementById("layerList");
      layerList.innerHTML = "";

      // Add drawn items
      if (drawnItems.getLayers().length > 0) {
        drawnItems.eachLayer((layer, index) => {
          const layerItem = createLayerItem(
            `Drawing ${drawnItems.getLayers().indexOf(layer) + 1}`,
            layer,
            "drawn"
          );
          layerList.appendChild(layerItem);
        });
      }

      // Add uploaded layers
      Object.keys(overlayLayers).forEach((name) => {
        const layerItem = createLayerItem(
          name,
          overlayLayers[name],
          "overlay"
        );
        layerList.appendChild(layerItem);
      });

      if (layerList.innerHTML === "") {
        layerList.innerHTML =
          '<div style="text-align: center; color: #666; font-size: 12px; padding: 10px;">No layers available</div>';
      }
    }

    // Create layer item
    function createLayerItem(name, layer, type) {
      const div = document.createElement("div");
      div.className = "layer-item";

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "layer-checkbox";
      checkbox.checked = map.hasLayer(layer);
      checkbox.onchange = function () {
        if (this.checked) {
          map.addLayer(layer);
        } else {
          map.removeLayer(layer);
        }
      };

      const nameSpan = document.createElement("span");
      nameSpan.className = "layer-name";
      nameSpan.textContent = name;

      const opacity = document.createElement("input");
      opacity.type = "range";
      opacity.className = "layer-opacity";
      opacity.min = "0";
      opacity.max = "1";
      opacity.step = "0.1";
      opacity.value = (layer.options && typeof layer.options.opacity !== "undefined") ? layer.options.opacity : 1;
      opacity.onchange = function () {
        if (layer.setStyle) {
          layer.setStyle({
            opacity: this.value,
            fillOpacity: this.value * 0.5,
          });
        } else if (layer.setOpacity) {
          layer.setOpacity(this.value);
        }
      };

      div.appendChild(checkbox);
      div.appendChild(nameSpan);
      div.appendChild(opacity);

      return div;
    }

    let currentRasterLayer = null;


    // Initialize everything when page loads
    document.addEventListener("DOMContentLoaded", function () {
      fetchNgrokConfig().then(() => {
        console.log("Configuration loaded, initializing map.");
        initializeMap();
        initializeSearch(); // Initialize enhanced search functionality
        let elevationProfileDrawingActive = false; // <-- Move this to the top!

        // Only add draw control ONCE
        if (!window.elevationDrawControl) {
          window.elevationDrawnItems = new L.FeatureGroup().addTo(map);
          window.elevationDrawControl = new L.Control.Draw({
            draw: {
              polyline: {
                shapeOptions: { color: '#FF0000', weight: 3 }
              },
              polygon: false,
              circle: false,
              rectangle: false,
              marker: false,
              circlemarker: false
            },
            edit: { featureGroup: window.elevationDrawnItems }
          });
          map.addControl(window.elevationDrawControl);
        }

        // Replace the existing elevation profile button click handler with this improved version
const elevationBtn = document.getElementById('elevation-profile-btn');
if (elevationBtn) {
  elevationBtn.onclick = function () {
    const panel = document.getElementById('elevation-profile-panel');
    
    // Always start drawing mode when button is clicked
    console.log("Elevation Profile button clicked!");
    
    // Clear any existing elevation data
    window.elevationDrawnItems.clearLayers();
    if (window.elevationMarker) {
      map.removeLayer(window.elevationMarker);
    }
    
    // Show the panel
    panel.style.display = 'block';
    
    // Activate drawing mode
    elevationProfileDrawingActive = true;
    const elevationPolylineDrawer = new L.Draw.Polyline(map, window.elevationDrawControl.options.draw.polyline);
    elevationPolylineDrawer.enable();
  };
} else {
  console.error('Elevation Profile button not found!');
}

        // Function to interpolate points along a line
        function interpolatePoints(start, end, numPoints) {
          const points = [];
          for (let i = 0; i <= numPoints; i++) {
            const ratio = i / numPoints;
            const lat = start.lat + (end.lat - start.lat) * ratio;
            const lng = start.lng + (end.lng - start.lng) * ratio;
            points.push({ lat, lng });
          }
          return points;
        }

        // Function to sample points along the entire path
        function samplePathPoints(latlngs, sampleDistance = 100) { // Sample every 100 meters
          const sampledPoints = [];
          let totalDistance = 0;

          sampledPoints.push(latlngs[0]); // Always include the first point

          for (let i = 1; i < latlngs.length; i++) {
            const segmentDistance = map.distance(latlngs[i - 1], latlngs[i]);
            const numSamples = Math.ceil(segmentDistance / sampleDistance);

            // Interpolate points along this segment
            const interpolatedPoints = interpolatePoints(latlngs[i - 1], latlngs[i], numSamples);

            // Add all interpolated points except the first one (to avoid duplicates)
            for (let j = 1; j < interpolatedPoints.length; j++) {
              sampledPoints.push(interpolatedPoints[j]);
            }
          }

          return sampledPoints;
        }

        // Function to batch elevation requests (Open-Elevation API has limits)
        async function fetchElevationBatch(points, batchSize = 100) {
          const allElevations = [];

          for (let i = 0; i < points.length; i += batchSize) {
            const batch = points.slice(i, i + batchSize);
            const path = batch.map(p => `${p.lat},${p.lng}`).join('|');

            try {
              const url = `https://api.open-elevation.com/api/v1/lookup?locations=${path}`;
              const response = await fetch(url);
              const data = await response.json();

              if (data.results) {
                allElevations.push(...data.results.map(r => r.elevation));
              }

              // Add a small delay to avoid rate limiting
              if (i + batchSize < points.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            } catch (error) {
              console.error('Error fetching elevation batch:', error);
              // Fill with null values for failed requests
              allElevations.push(...new Array(batch.length).fill(null));
            }
          }

          return allElevations;
        }

        // Function to calculate cumulative distances
        function calculateDistances(points) {
          const distances = [0];
          for (let i = 1; i < points.length; i++) {
            const d = map.distance(points[i - 1], points[i]) / 1000; // km
            distances.push(distances[distances.length - 1] + d);
          }
          return distances;
        }

        // Function to calculate detailed statistics
        function calculateStats(elevations, distances) {
          const validElevations = elevations.filter(e => e !== null);

          if (validElevations.length === 0) {
            return null;
          }

          const minElev = Math.min(...validElevations);
          const maxElev = Math.max(...validElevations);
          const avgElev = Math.round(validElevations.reduce((a, b) => a + b, 0) / validElevations.length);

          // Calculate elevation gain and loss with more precision
          let elevGain = 0, elevLoss = 0;
          let currentElev = elevations[0];

          for (let i = 1; i < elevations.length; i++) {
            if (elevations[i] !== null && currentElev !== null) {
              const diff = elevations[i] - currentElev;
              if (diff > 0) {
                elevGain += diff;
              } else {
                elevLoss += Math.abs(diff);
              }
              currentElev = elevations[i];
            }
          }

          // Calculate slopes with more precision
          let maxSlopeUp = 0, maxSlopeDown = 0, sumSlopeUp = 0, sumSlopeDown = 0, countUp = 0, countDown = 0;

          for (let i = 1; i < elevations.length; i++) {
            if (elevations[i] !== null && elevations[i - 1] !== null) {
              const distanceM = (distances[i] - distances[i - 1]) * 1000; // meters
              if (distanceM > 0) {
                const slope = (elevations[i] - elevations[i - 1]) / distanceM * 100; // percent
                if (slope > 0) {
                  sumSlopeUp += slope;
                  countUp++;
                  if (slope > maxSlopeUp) maxSlopeUp = slope;
                } else {
                  sumSlopeDown += Math.abs(slope);
                  countDown++;
                  if (Math.abs(slope) > maxSlopeDown) maxSlopeDown = Math.abs(slope);
                }
              }
            }
          }

          const avgSlopeUp = countUp ? (sumSlopeUp / countUp) : 0;
          const avgSlopeDown = countDown ? (sumSlopeDown / countDown) : 0;

          return {
            minElev,
            maxElev,
            avgElev,
            elevGain,
            elevLoss,
            maxSlopeUp,
            maxSlopeDown,
            avgSlopeUp,
            avgSlopeDown,
            totalDistance: distances[distances.length - 1]
          };
        }

        // Handle path drawing and fetch elevation data
        map.on(L.Draw.Event.CREATED, async function (e) {
          if (!elevationProfileDrawingActive) return;
          elevationProfileDrawingActive = false;

          const layer = e.layer;
          window.elevationDrawnItems.clearLayers();
          window.elevationDrawnItems.addLayer(layer);

          // Get latlngs from the drawn polyline
          const originalPoints = layer.getLatLngs();

          // Show loading message
          document.getElementById('elevation-summary-content').innerHTML = `
        <span style="color:#FFA500;">Loading elevation data...</span>
      `;

          try {
            // Sample points along the entire path (every 50-100 meters for high precision)
            const sampledPoints = samplePathPoints(originalPoints, 50);
            console.log(`Sampled ${sampledPoints.length} points along the path`);

            // Fetch elevation data in batches
            const elevations = await fetchElevationBatch(sampledPoints);

            // Calculate distances for sampled points
            const distances = calculateDistances(sampledPoints);

            // Calculate comprehensive statistics
            const stats = calculateStats(elevations, distances);

            if (!stats) {
              throw new Error('Could not calculate elevation statistics');
            }

            // Update summary bar with detailed information
            document.getElementById('elevation-summary-content').innerHTML = `<span>Elevation (Min, Avg, Max): <span style="color:#fff;">${stats.minElev} m, ${stats.avgElev} m, <span style="color:#FF0000;font-weight:bold;">${stats.maxElev} m, ${stats.avgElev} m, <span style="color:#FF0000;font-weight:bold;">${stats.maxElev} m</span></span></span>
          <span>Distance: <span style="color:#fff;">${stats.totalDistance.toFixed(2)} km</span></span>
          <span>Gain/Loss: <span style="color:#fff;">${Math.round(stats.elevGain)} m / ${Math.round(stats.elevLoss)} m</span></span>
          <span>Slope (max/avg up): <span style="color:#fff;">${stats.maxSlopeUp.toFixed(1)}% / ${stats.avgSlopeUp.toFixed(1)}%</span></span>
          <span>Slope (max/avg down): <span style="color:#fff;">${stats.maxSlopeDown.toFixed(1)}% / ${stats.avgSlopeDown.toFixed(1)}%</span></span>
          <span>Sample Points: <span style="color:#fff;">${sampledPoints.length}</span></span>
        `;

            statsText =
              `Elevation (Min, Avg, Max): ${stats.minElev} m, ${stats.avgElev} m, ${stats.maxElev} m\n` +
              `Distance: ${stats.totalDistance.toFixed(2)} km\n` +
              `Gain/Loss: ${Math.round(stats.elevGain)} m / ${Math.round(stats.elevLoss)} m\n` +
              `Slope (max/avg up): ${stats.maxSlopeUp.toFixed(1)}% / ${stats.avgSlopeUp.toFixed(1)}%\n` +
              `Slope (max/avg down): ${stats.maxSlopeDown.toFixed(1)}% / ${stats.avgSlopeDown.toFixed(1)}%\n` +
              `Sample Points: ${sampledPoints.length}`;



            // Create enhanced Plotly chart with hover information
            const trace = {
              x: distances,
              y: elevations,
              type: 'scatter',
              mode: 'lines',
              line: { color: '#FF0000', width: 2 },
              fill: 'tozeroy',
              fillcolor: 'rgba(255,0,0,0.2)',
              hovertemplate: '<b>Distance:</b> %{x:.2f} km<br><b>Elevation:</b> %{y:.0f} m<extra></extra>',
              name: 'Elevation'
            };

            const layout = {
              margin: { t: 10, r: 10, l: 50, b: 50 },
              xaxis: {
                title: 'Distance (km)',
                gridcolor: '#CCCCCC',
                tickfont: { family: 'Roboto, sans-serif', color: '#888' },
                titlefont: { family: 'Roboto, sans-serif', color: '#888' },
                zeroline: false
              },
              yaxis: {
                title: 'Elevation (m)',
                gridcolor: '#CCCCCC',
                tickfont: { family: 'Roboto, sans-serif', color: '#888' },
                titlefont: { family: 'Roboto, sans-serif', color: '#888' },
                zeroline: false
              },
              plot_bgcolor: 'rgba(255,255,255,1)',
              paper_bgcolor: 'rgba(247,247,247,1)',
              showlegend: false,
              hovermode: 'closest'

            };

            const config = {
              displayModeBar: true,
              modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d'],
              displaylogo: false
            };



            Plotly.newPlot('elevation-chart', [trace], layout, config).then(function (chartDiv) {
              // Remove any previous handlers to avoid duplicates
              if (chartDiv.removeAllListeners) {
                chartDiv.removeAllListeners('plotly_beforeexport');
                chartDiv.removeAllListeners('plotly_afterexport');
              }

              chartDiv.on('plotly_beforeexport', function (eventData) {
                console.log('plotly_beforeexport fired');
                return Plotly.relayout(chartDiv, {
                  annotations: [{
                    text: statsText.replace(/\n/g, '<br>'),
                    xref: 'paper',
                    yref: 'paper',
                    x: 0,
                    y: 1.05, // instead of 1.18
                    xanchor: 'left',
                    yanchor: 'top',
                    align: 'left',
                    showarrow: false,
                    font: { family: 'Roboto, monospace', size: 14, color: '#222' },
                    bgcolor: 'rgba(0,0,0,0.05)',
                    borderpad: 4
                  }],
                  'margin.t': 110
                });
              });

              chartDiv.on('plotly_afterexport', function (eventData) {
                console.log('plotly_afterexport fired');
                return Plotly.relayout(chartDiv, {
                  annotations: [],
                  'margin.t': 10
                });
              });
            });



            // Add click event to show position on map
            document.getElementById('elevation-chart').on('plotly_click', function (data) {
              const pointIndex = data.points[0].pointIndex;
              const point = sampledPoints[pointIndex];

              // Remove existing marker
              if (window.elevationMarker) {
                map.removeLayer(window.elevationMarker);
              }

              // Add new marker
              window.elevationMarker = L.marker([point.lat, point.lng], {
                icon: L.divIcon({
                  className: 'elevation-marker',
                  html: '<div style="background: #FF0000; border-radius: 50%; width: 10px; height: 10px; border: 2px solid white;"></div>',
                  iconSize: [10, 10],
                  iconAnchor: [5, 5]
                })
              }).addTo(map);

              // Pan to marker
              map.setView([point.lat, point.lng], map.getZoom());
            });

          } catch (error) {
            console.error('Error fetching elevation data:', error);
            document.getElementById('elevation-summary-content').innerHTML = `
          <span style="color:#FF0000;">Error: Could not fetch elevation data. Please try again.</span>
        `;
          }
        });

        document.getElementById('export-elevation-png').onclick = function () {
          const chartDiv = document.getElementById('elevation-chart');
          // Add annotation with smaller font and reduced top margin
          Plotly.relayout(chartDiv, {
            annotations: [{
              text: statsText.replace(/\n/g, '<br>'),
              xref: 'paper',
              yref: 'paper',
              x: 0,
              y: 1.05,
              xanchor: 'left',
              yanchor: 'top',
              align: 'left',
              showarrow: false,
              font: { family: 'Roboto, monospace', size: 10, color: '#222' }, // smaller font
              bgcolor: 'rgba(0,0,0,0.05)',
              borderpad: 4
            }],
            'margin.t': 40 // reduced top margin
          }).then(() => {
            // Download image
            Plotly.downloadImage(chartDiv, {
              format: 'png',
              filename: 'elevation-profile'
            }).then(() => {
              // Remove annotation after export, restore default margin
              Plotly.relayout(chartDiv, {
                annotations: [],
                'margin.t': 10
              });
            });
          });
        };






        // Add close button functionality for elevation panel
        const closeBtn = document.querySelector('#elevation-profile-panel .close-btn');
        if (closeBtn) {
          closeBtn.onclick = function () {
            document.getElementById('elevation-profile-panel').style.display = 'none';
            window.elevationDrawnItems.clearLayers();
            if (window.elevationMarker) {
              map.removeLayer(window.elevationMarker);
            }
          };
        }












        // Raster selector logic

        const rasterSelector = document.getElementById("rasterSelector");
        if (rasterSelector) {
          rasterSelector.addEventListener("change", function () {
            const rasterName = this.value;
            // Remove previous raster layer
            if (currentRasterLayer) {
              map.removeLayer(currentRasterLayer);
              delete overlayLayers[currentRasterLayer.options.layers];
              currentRasterLayer = null;
            }
            if (rasterName === "Orthomosaic_Tuljapur_City") {
              if (typeof proj4 !== 'undefined' && !proj4.defs['EPSG:32643']) {
                proj4.defs('EPSG:32643', '+proj=utm +zone=43 +datum=WGS84 +units=m +no_defs');
              }
              currentRasterLayer = L.tileLayer.wms(
                `${GEOSERVER_URL}/rasterdrone/wms`,
                {
                  layers: "rasterdrone:Tuljapur Town Full Ortho_Final",
                  format: "image/png",
                  transparent: true,
                  version: "1.1.0",
                  attribution: "GeoServer Raster WMS",
                  crs: L.CRS.EPSG3857,
                  maxZoom: 22,
                  minZoom: 0,
                  opacity: 0.8,
                  zIndex: 100,
                }
              ).addTo(map);
              overlayLayers[currentRasterLayer.options.layers] = currentRasterLayer;
              // Fit to bounding box (EPSG:32643)
              if (typeof proj4 !== 'undefined') {
                const sw = proj4('EPSG:32643', 'WGS84', [611814.4521386125, 1989669.0247925709]);
                const ne = proj4('EPSG:32643', 'WGS84', [614729.4673730126, 1993871.443594171]);
                map.fitBounds([
                  [sw[1], sw[0]],
                  [ne[1], ne[0]]
                ]);
              }
            } else if (rasterName === "temple_complex_raster") {
              if (typeof proj4 !== 'undefined' && !proj4.defs['EPSG:32643']) {
                proj4.defs('EPSG:32643', '+proj=utm +zone=43 +datum=WGS84 +units=m +no_defs');
              }
              currentRasterLayer = L.tileLayer.wms(
                `${GEOSERVER_URL}/rasterdrone/wms`,
                {
                  layers: "rasterdrone:Bhavani Temple and Bharati Buva Math Orthomosaic",
                  format: "image/png",

                  version: "1.1.0",
                  attribution: "GeoServer Raster WMS",
                  crs: L.CRS.EPSG3857,
                  maxZoom: 22,
                  minZoom: 0,
                  opacity: 0.8,
                  zIndex: 100,
                }
              ).addTo(map);
              overlayLayers[currentRasterLayer.options.layers] = currentRasterLayer;
              // Fit to bounding box (EPSG:32643)
              if (typeof proj4 !== 'undefined') {
                const sw = proj4('EPSG:32643', 'WGS84', [612272.607412908, 1991496.2286072166]);
                const ne = proj4('EPSG:32643', 'WGS84', [613141.591732108, 1992206.9842552166]);
                map.fitBounds([
                  [sw[1], sw[0]],
                  [ne[1], ne[0]]
                ]);
              }
            }
            else if (rasterName === "temple_complex_dem") {
              if (typeof proj4 !== 'undefined' && !proj4.defs['EPSG:32643']) {
                proj4.defs('EPSG:32643', '+proj=utm +zone=43 +datum=WGS84 +units=m +no_defs');
              }

              currentRasterLayer = L.tileLayer.wms(

                `${GEOSERVER_URL}/rasterdrone/wms`,
                {
                  layers: "rasterdrone:Bhavani Temple and Bharati Buva Math DTM-DEM",
                  styles: "Temple Complex DEM",
                  format: "image/png",
                  transparent: true,
                  version: "1.1.0",
                  attribution: "GeoServer Raster WMS",
                  crs: L.CRS.EPSG3857,
                  maxZoom: 22,
                  minZoom: 0,
                  opacity: 0.8,
                  zIndex: 10000,
                }
              ).addTo(map);
              overlayLayers[currentRasterLayer.options.layers] = currentRasterLayer;
              // Fit to bounding box (EPSG:32643 -> WGS84)
              if (typeof proj4 !== 'undefined') {
                const sw = proj4('EPSG:32643', 'WGS84', [611961.0268728782, 1991136.2639710158]);
                const ne = proj4('EPSG:32643', 'WGS84', [613523.0368304782, 1992583.7676166159]);
                map.fitBounds([
                  [sw[1], sw[0]],
                  [ne[1], ne[0]]
                ]);
              }

              // Fetch all DEM features once
              demFeatures = []; // clear previous
              const wfsUrl = `${GEOSERVER_URL}/rasterdrone/wfs`;
              const params = [
                "service=WFS",
                "version=1.1.0",
                "request=GetFeature",
                `typeName=${encodeURIComponent("rasterdrone:Bhavani_Temple_and_Bharati_Buva_Math_DTM-DEM")}`,
                "outputFormat=application/json",
                "srsName=EPSG:4326"
              ].join("&");
              const proxyWfsUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(`${wfsUrl}?${params}`)}`;
              // --- Place at the top of your script ---
              const DEM_NATIVE_BBOX = [
                611961.0268728782, 1991136.2639710158,
                613523.0368304782, 1992583.7676166159
              ];
              const DEM_NATIVE_WIDTH = 768;
              const DEM_NATIVE_HEIGHT = 711;

              // ... rest of your code ...
              // Enable DEM elevation query on click
              // Remove previous click handler if any
              if (demClickHandler) {
                map.off('click', demClickHandler);
              }
              demClickHandler = function (e) {
                const wmsUrl = `${GEOSERVER_URL}/rasterdrone/wms`;
                const layerName = "rasterdrone:Bhavani Temple and Bharati Buva Math DTM-DEM";
                const [minX, minY, maxX, maxY] = DEM_NATIVE_BBOX;
                const width = DEM_NATIVE_WIDTH;
                const height = DEM_NATIVE_HEIGHT;

                // Reproject click to EPSG:32643
                const utm = proj4('WGS84', 'EPSG:32643', [e.latlng.lng, e.latlng.lat]);
                const xMeters = utm[0];
                const yMeters = utm[1];

                // Calculate pixel coordinates
                const xPixel = Math.round((xMeters - minX) / (maxX - minX) * width);
                const yPixel = Math.round((maxY - yMeters) / (maxY - minY) * height);

                const params = {
                  service: 'WMS',
                  request: 'GetFeatureInfo',
                  srs: 'EPSG:32643',
                  styles: '',
                  transparent: true,
                  version: '1.1.0',
                  format: 'image/png',
                  bbox: DEM_NATIVE_BBOX.join(','),
                  height: height,
                  width: width,
                  layers: layerName,
                  query_layers: layerName,
                  info_format: 'text/plain',
                  x: xPixel,
                  y: yPixel
                };

                const paramString = Object.keys(params)
                  .map(key => `${key}=${encodeURIComponent(params[key])}`)
                  .join('&');
                const getFeatureInfoUrl = `${wmsUrl}?${paramString}`;
                const proxyUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(getFeatureInfoUrl)}`;

                fetch(proxyUrl, {
                  headers: { 'ngrok-skip-browser-warning': 'true' }
                })
                  .then(response => response.text())
                  .then(data => {
                    const match = data.match(/GRAY_INDEX\s*=\s*([0-9.\-eE]+)/);
                    if (match) {
                      const elevation = parseFloat(match[1]);
                      alert(`Elevation: ${elevation}`);
                    } else {
                      alert('No DEM data at this location.');
                    }
                  })
                  .catch(err => {
                    alert('Error fetching DEM value.');
                    console.error(err);
                  });
              };
              map.on('click', demClickHandler);
            } else {
              // Remove DEM click handler if another raster is selected
              if (demClickHandler) {
                map.off('click', demClickHandler);
                demClickHandler = null;
              }
            }
          });
        }
      });
    });

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function getFeatureInfoUrl(layer, latlng, map) {
      // Construct a WMS GetFeatureInfo request URL
      const point = map.latLngToContainerPoint(latlng, map.getZoom());
      const size = map.getSize();

      // WMS parameters
      const params = {
        request: 'GetFeatureInfo',
        service: 'WMS',
        srs: 'EPSG:4326',
        styles: '',
        transparent: true,
        version: '1.1.0',
        format: 'image/png',
        bbox: map.getBounds().toBBoxString(),
        height: size.y,
        width: size.x,
        layers: layer.options.layers,
        query_layers: layer.options.layers,
        info_format: 'application/json'
      };

      // WMS 1.1.0 expects x/y, not i/j
      params.x = Math.round(point.x);
      params.y = Math.round(point.y);

      // Build the URL
      return layer._url + L.Util.getParamString(params, layer._url, true);
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





    // Utility Functions
    function toggleUtilityTool(toolName) {
      utilityToolsState[toolName] = !utilityToolsState[toolName];

      switch (toolName) {
        case 'gridOverlay':
          toggleGridOverlay();
          break;
        case 'graticule':
          toggleGraticule();
          break;
        case 'crosshairs':
          toggleCrosshairs();
          break;
        case 'mousePosition':
          toggleMousePosition();
          break;
        case 'unitsConverter':
          toggleUnitsConverter();
          break;
      }

      // Update button appearance
      updateUtilityToolButton(toolName);
    }

    // Activate utility tools (temporary activation)
    function activateUtilityTool(toolName) {
      // Deactivate other active tools first
      deactivateAllUtilityTools();

      switch (toolName) {
        case 'distanceFromPoint':
          activateDistanceFromPoint();
          break;
        case 'bearingCalculator':
          activateBearingCalculator();
          break;
        case 'slopeAnalysis':
          activateSlopeAnalysis();
          break;
      }
    }

    // Open utility tool dialogs
    function openUtilityTool(toolName) {
      switch (toolName) {
        case 'coordinateConverter':
          openCoordinateConverter();
          break;
      }
    }

    // Grid Overlay Implementation
    function toggleGridOverlay() {
      if (utilityToolsState.gridOverlay) {
        addGridOverlay();
      } else {
        removeGridOverlay();
      }
    }

    function addGridOverlay() {
      if (gridLayer) return;

      gridLayer = L.layerGroup();

      const bounds = map.getBounds();
      const zoom = map.getZoom();

      // Calculate grid spacing based on zoom level
      let gridSpacing = 0.01; // degrees
      if (zoom > 10) gridSpacing = 0.001;
      if (zoom > 15) gridSpacing = 0.0001;
      if (zoom < 8) gridSpacing = 0.1;
      if (zoom < 5) gridSpacing = 1;

      // Create vertical lines
      for (let lng = Math.floor(bounds.getWest() / gridSpacing) * gridSpacing;
        lng <= bounds.getEast();
        lng += gridSpacing) {
        const line = L.polyline([
          [bounds.getSouth(), lng],
          [bounds.getNorth(), lng]
        ], {
          color: '#666',
          weight: 1,
          opacity: 0.5
        });
        gridLayer.addLayer(line);
      }

      // Create horizontal lines
      for (let lat = Math.floor(bounds.getSouth() / gridSpacing) * gridSpacing;
        lat <= bounds.getNorth();
        lat += gridSpacing) {
        const line = L.polyline([
          [lat, bounds.getWest()],
          [lat, bounds.getEast()]
        ], {
          color: '#666',
          weight: 1,
          opacity: 0.5
        });
        gridLayer.addLayer(line);
      }

      gridLayer.addTo(map);
    }

    function removeGridOverlay() {
      if (gridLayer) {
        map.removeLayer(gridLayer);
        gridLayer = null;
      }
    }

    // Graticule Implementation
    function toggleGraticule() {
      if (utilityToolsState.graticule) {
        addGraticule();
      } else {
        removeGraticule();
      }
    }

    function addGraticule() {
      if (graticuleLayer) return;

      graticuleLayer = L.layerGroup();

      // Add degree lines every 10 degrees
      for (let lat = -80; lat <= 80; lat += 10) {
        const line = L.polyline([
          [lat, -180],
          [lat, 180]
        ], {
          color: '#ff0000',
          weight: 1,
          opacity: 0.7,
          dashArray: '5, 5'
        });

        // Add label
        const label = L.marker([lat, 0], {
          icon: L.divIcon({
            className: 'graticule-label',
            html: `${lat}¬∞`,
            iconSize: [30, 20]
          })
        });

        graticuleLayer.addLayer(line);
        graticuleLayer.addLayer(label);
      }

      for (let lng = -180; lng <= 180; lng += 10) {
        const line = L.polyline([
          [-85, lng],
          [85, lng]
        ], {
          color: '#ff0000',
          weight: 1,
          opacity: 0.7,
          dashArray: '5, 5'
        });

        // Add label
        const label = L.marker([0, lng], {
          icon: L.divIcon({
            className: 'graticule-label',
            html: `${lng}¬∞`,
            iconSize: [30, 20]
          })
        });

        graticuleLayer.addLayer(line);
        graticuleLayer.addLayer(label);
      }

      graticuleLayer.addTo(map);
    }

    function removeGraticule() {
      if (graticuleLayer) {
        map.removeLayer(graticuleLayer);
        graticuleLayer = null;
      }
    }

    // Crosshairs Implementation
    function toggleCrosshairs() {
      if (utilityToolsState.crosshairs) {
        addCrosshairs();
      } else {
        removeCrosshairs();
      }
    }

    function addCrosshairs() {
      if (crosshairsMarker) return;

      const center = map.getCenter();
      crosshairsMarker = L.marker(center, {
        icon: L.divIcon({
          className: 'crosshairs-icon',
          html: '<i class="fas fa-crosshairs" style="font-size: 24px; color: red;"></i>',
          iconSize: [30, 30],
          iconAnchor: [15, 15]
        }),
        draggable: false
      }).addTo(map);

      // Update crosshairs position on map move
      map.on('move', updateCrosshairs);
    }

    function updateCrosshairs() {
      if (crosshairsMarker) {
        crosshairsMarker.setLatLng(map.getCenter());
      }
    }

    function removeCrosshairs() {
      if (crosshairsMarker) {
        map.removeLayer(crosshairsMarker);
        crosshairsMarker = null;
        map.off('move', updateCrosshairs);
      }
    }

    let mousePositionControl = null;
    let mousePositionUpdateHandler = null;

    // Mouse Position Implementation
    function toggleMousePosition() {

      if (utilityToolsState.mousePosition) {
        addMousePosition();
      } else {
        removeMousePosition();
      }
    }

    function addMousePosition() {
      console.log("addMousePosition called")
      if (mousePositionControl) {
        return; // Already added
      }

      mousePositionControl = L.control({ position: 'bottomright' });

      mousePositionControl.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'mouse-position-control');
        this._div.style.background = 'rgba(0, 0, 0, 0.8)';
        this._div.style.color = 'white';
        this._div.style.padding = '5px 10px';
        this._div.style.borderRadius = '5px';
        this._div.style.fontSize = '12px';
        this._div.style.fontFamily = 'monospace';
        this._div.innerHTML = 'Move mouse over map';
        return this._div;
      };

      mousePositionControl.update = function (lat, lng) {
        if (this._div) {
          this._div.innerHTML = `Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}`;
        }
      };

      mousePositionControl.addTo(map);

      // Add mousemove event listener
      mousePositionUpdateHandler = function (e) {
        console.log("mousemove", e.latlng);
        if (mousePositionControl && mousePositionControl.update) {
          mousePositionControl.update(e.latlng.lat, e.latlng.lng);
        }
      };
      map.on('mousemove', mousePositionUpdateHandler);
    }

    function removeMousePosition() {
      if (mousePositionControl) {
        map.removeControl(mousePositionControl);
        mousePositionControl = null;
      }
      if (mousePositionUpdateHandler) {
        map.off('mousemove', mousePositionUpdateHandler);
        mousePositionUpdateHandler = null;
      }
    }

    // Distance from Point Implementation
    function activateDistanceFromPoint() {
      // Clear any existing distance circles
      if (distanceCircles && distanceCircles.length > 0) {
        distanceCircles.forEach(circle => {
          if (circle && map.hasLayer(circle)) {
            map.removeLayer(circle);
          }
        });
        distanceCircles = [];
      }

      map.getContainer().style.cursor = 'crosshair';

      const instruction = L.control({ position: 'topright' });
      instruction.onAdd = function () {
        const div = L.DomUtil.create('div', 'instruction-control');
        div.innerHTML = 'Click on map to set center point for distance measurement';
        div.style.background = 'white';
        div.style.padding = '10px';
        div.style.borderRadius = '5px';
        div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        div.style.zIndex = '1000';
        return div;
      };
      instruction.addTo(map);

      function onMapClick(e) {
        // Remove instruction
        map.removeControl(instruction);

        // Clear previous circles
        distanceCircles.forEach(circle => {
          if (circle && map.hasLayer(circle)) {
            map.removeLayer(circle);
          }
        });
        distanceCircles = [];

        const centerPoint = e.latlng;

        // Add center marker
        const centerMarker = L.marker(centerPoint, {
          icon: L.divIcon({
            className: 'center-point',
            html: '<i class="fas fa-bullseye" style="color: red; font-size: 20px;"></i>',
            iconSize: [25, 25],
            iconAnchor: [12, 12]
          })
        }).addTo(map);

        // Add distance circles (1km, 5km, 10km)
        const distances = [1000, 5000, 10000]; // meters
        const colors = ['#ff0000', '#00ff00', '#0000ff'];
        const labels = ['1 km', '5 km', '10 km'];

        distances.forEach((distance, index) => {
          const circle = L.circle(centerPoint, {
            radius: distance,
            color: colors[index],
            fillColor: colors[index],
            fillOpacity: 0.1,
            weight: 2
          }).addTo(map);

          // Add distance label
          const label = L.marker(centerPoint, {
            icon: L.divIcon({
              className: 'distance-label',
              html: `<div style="background: white; padding: 2px 5px; border-radius: 3px; font-size: 12px;">${labels[index]}</div>`,
              iconSize: [50, 20],
              iconAnchor: [25, 10]
            })
          }).addTo(map);

          // Position label on the circle
          const angle = (index * 45) * Math.PI / 180; // Spread labels around the circle
          const labelLat = centerPoint.lat + (distance / 111000) * Math.sin(angle);
          const labelLng = centerPoint.lng + (distance / (111000 * Math.cos(centerPoint.lat * Math.PI / 180))) * Math.cos(angle);
          label.setLatLng([labelLat, labelLng]);

          distanceCircles.push(circle);
          distanceCircles.push(label);
        });

        distanceCircles.push(centerMarker);

        map.off('click', onMapClick);
        map.getContainer().style.cursor = '';
      }

      map.on('click', onMapClick);
    }

    // Bearing Calculator Implementation
    function activateBearingCalculator() {
      map.getContainer().style.cursor = 'crosshair';
      let firstPoint = null;

      const instruction = L.control({ position: 'topright' });
      instruction.onAdd = function () {
        const div = L.DomUtil.create('div', 'instruction-control');
        div.innerHTML = 'Click two points to calculate bearing';
        div.style.background = 'white';
        div.style.padding = '10px';
        div.style.borderRadius = '5px';
        div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        return div;
      };
      instruction.addTo(map);

      function onMapClick(e) {
        if (!firstPoint) {
          firstPoint = e.latlng;

          // Add first point marker
          L.marker(firstPoint, {
            icon: L.divIcon({
              className: 'bearing-point',
              html: '<div style="background: red; width: 10px; height: 10px; border-radius: 50%;"></div>',
              iconSize: [10, 10],
              iconAnchor: [5, 5]
            })
          }).addTo(map);

          instruction._div.innerHTML = 'Click second point';
        } else {
          const secondPoint = e.latlng;

          // Add second point marker
          L.marker(secondPoint, {
            icon: L.divIcon({
              className: 'bearing-point',
              html: '<div style="background: blue; width: 10px; height: 10px; border-radius: 50%;"></div>',
              iconSize: [10, 10],
              iconAnchor: [5, 5]
            })
          }).addTo(map);

          // Calculate bearing
          const bearing = calculateBearing(firstPoint, secondPoint);
          const distance = firstPoint.distanceTo(secondPoint);

          // Draw line
          bearingLine = L.polyline([firstPoint, secondPoint], {
            color: 'green',
            weight: 3
          }).addTo(map);

          // Show results
          const popup = L.popup()
            .setLatLng(secondPoint)
            .setContent(`
                <div>
                  <strong>Bearing:</strong> ${bearing.toFixed(2)}¬∞<br>
                  <strong>Distance:</strong> ${(distance / 1000).toFixed(2)} km
                </div>
              `)
            .openOn(map);

          // Cleanup
          map.removeControl(instruction);
          map.off('click', onMapClick);
          map.getContainer().style.cursor = '';
        }
      }

      map.on('click', onMapClick);
    }

    function calculateBearing(point1, point2) {
      const lat1 = point1.lat * Math.PI / 180;
      const lat2 = point2.lat * Math.PI / 180;
      const deltaLng = (point2.lng - point1.lng) * Math.PI / 180;

      const x = Math.sin(deltaLng) * Math.cos(lat2);
      const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);

      const bearing = Math.atan2(x, y) * 180 / Math.PI;
      return (bearing + 360) % 360;
    }

    // Coordinate Converter Implementation
    function openCoordinateConverter() {
      const converterHTML = `
          <div id="coordinate-converter" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); 
               z-index: 2000; min-width: 400px;">
              <h3>Coordinate Converter</h3>
              <div style="margin: 15px 0;">
                  <label>Decimal Degrees:</label>
                  <input type="text" id="dd-input" placeholder="lat, lng" style="width: 100%; padding: 5px; margin: 5px 0;">
              </div>
              <div style="margin: 15px 0;">
                  <label>Degrees Minutes Seconds:</label>
                  <input type="text" id="dms-input" placeholder="40¬∞26'46"N 79¬∞58'56"W" style="width: 100%; padding: 5px; margin: 5px 0;">
              </div>
              <div style="margin: 15px 0;">
                  <label>UTM:</label>
                  <input type="text" id="utm-input" placeholder="Easting Northing" style="width: 60%; padding: 5px; margin: 5px 0;">
                  <select id="utm-zone-select" style="width: 35%; padding: 5px; margin: 5px 0 0 5px;">
                      <!-- Populate with common UTM zones -->
                      <option value="32643">Zone 43N</option>
                      <option value="32644">Zone 44N</option>
                      <option value="32645">Zone 45N</option>
                      <!-- Add more as needed -->
                  </select>
              </div>
              <div style="margin: 15px 0;">
                  <button onclick="convertCoordinates()" style="background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin-right: 10px;">Convert</button>
                  <button onclick="closeCoordinateConverter()" style="background: #e74c3c; color: white; border: none; padding: 10px 20px; border-radius: 5px;">Close</button>
              </div>
          </div>
          <div id="converter-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
               background: rgba(0,0,0,0.5); z-index: 1999;" onclick="closeCoordinateConverter()"></div>
        `;

      document.body.insertAdjacentHTML('beforeend', converterHTML);
    }

    function convertCoordinates() {
      const ddInput = document.getElementById('dd-input').value;
      const dmsInput = document.getElementById('dms-input').value;
      const utmInput = document.getElementById('utm-input').value;
      const utmZone = document.getElementById('utm-zone-select').value;

      // Decimal Degrees to DMS and UTM
      if (ddInput) {
        const [lat, lng] = ddInput.split(',').map(x => parseFloat(x.trim()));
        if (!isNaN(lat) && !isNaN(lng)) {
          document.getElementById('dms-input').value = convertDDToDMS(lat, lng);

          // UTM conversion using proj4
          if (typeof proj4 !== "undefined" && utmZone) {
            // Define the UTM projection if not already defined
            if (!proj4.defs[`EPSG:${utmZone}`]) {
              proj4.defs(`EPSG:${utmZone}`, `+proj=utm +zone=${parseInt(utmZone.slice(-2))} +datum=WGS84 +units=m +no_defs`);
            }
            const [easting, northing] = proj4('EPSG:4326', `EPSG:${utmZone}`, [lng, lat]);
            document.getElementById('utm-input').value = `${easting.toFixed(2)} ${northing.toFixed(2)}`;
          }
        }
      }

      // (Optional) UTM to Decimal Degrees
      if (utmInput && utmZone) {
        const [easting, northing] = utmInput.split(' ').map(x => parseFloat(x.trim()));
        if (!isNaN(easting) && !isNaN(northing) && typeof proj4 !== "undefined") {
          if (!proj4.defs[`EPSG:${utmZone}`]) {
            proj4.defs(`EPSG:${utmZone}`, `+proj=utm +zone=${parseInt(utmZone.slice(-2))} +datum=WGS84 +units=m +no_defs`);
          }
          const [lng, lat] = proj4(`EPSG:${utmZone}`, 'EPSG:4326', [easting, northing]);
          document.getElementById('dd-input').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          document.getElementById('dms-input').value = convertDDToDMS(lat, lng);
        }
      }
    }

    function convertDDToDMS(lat, lng) {
      function ddToDms(dd, isLng = false) {
        const deg = Math.floor(Math.abs(dd));
        const min = Math.floor((Math.abs(dd) - deg) * 60);
        const sec = Math.round(((Math.abs(dd) - deg) * 60 - min) * 60);
        const dir = dd >= 0 ? (isLng ? 'E' : 'N') : (isLng ? 'W' : 'S');
        return `${deg}¬∞${min}'${sec}"${dir}`;
      }

      return `${ddToDms(lat)} ${ddToDms(lng, true)}`;
    }

    function closeCoordinateConverter() {
      const converter = document.getElementById('coordinate-converter');
      const overlay = document.getElementById('converter-overlay');
      if (converter) converter.remove();
      if (overlay) overlay.remove();
    }

    // Units Converter Implementation
    function toggleUnitsConverter() {
      currentUnit = currentUnit === 'metric' ? 'imperial' : 'metric';
      updateUnitsDisplay();
      updateAllMeasurements();
    }

    function updateUnitsDisplay() {
      const unitText = currentUnit === 'metric' ? 'Metric (km/m¬≤)' : 'Imperial (mi/ft¬≤)';

      // Show notification
      const notification = L.control({ position: 'topright' });
      notification.onAdd = function () {
        const div = L.DomUtil.create('div', 'units-notification');
        div.innerHTML = `Units switched to: ${unitText}`;
        div.style.background = '#2ecc71';
        div.style.color = 'white';
        div.style.padding = '10px';
        div.style.borderRadius = '5px';
        div.style.zIndex = '1000';
        return div;
      };
      notification.addTo(map);

      setTimeout(() => {
        map.removeControl(notification);
      }, 2000);
    }

    function updateAllMeasurements() {
      // Update measurementLayer (where drawn measurements are stored)
      if (measurementLayer) {
        measurementLayer.eachLayer(layer => {
          let popupContent = '';
          if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
            // Distance
            const latlngs = layer.getLatLngs();
            const distance = calculateDistance(latlngs);
            popupContent = `<b>Distance:</b><br>${formatMeasurement(distance, "distance")}`;
          } else if (layer instanceof L.Polygon) {
            // Area
            const latlngs = layer.getLatLngs()[0];
            const area = calculateArea(latlngs);
            popupContent = `<b>Area:</b><br>${formatMeasurement(area, "area")}`;
          }
          if (popupContent && layer.getPopup()) {
            layer.setPopupContent(popupContent);
          }
        });
      }
    }

    function convertDistance(distance) {
      if (currentUnit === 'metric') {
        // Convert from imperial to metric
        return distance * 1.60934; // miles to kilometers
      } else {
        // Convert from metric to imperial
        return distance * 0.621371; // kilometers to miles
      }
    }

    function formatDistance(distance) {
      if (currentUnit === 'metric') {
        return `${(distance / 1000).toFixed(2)} km`;
      } else {
        return `${(distance / 1609.34).toFixed(2)} mi`;
      }
    }

    function convertArea(area) {
      if (currentUnit === 'metric') {
        // Convert from imperial to metric
        return area * 2.58999; // square miles to square kilometers
      } else {
        // Convert from metric to imperial
        return area * 0.386102; // square kilometers to square miles
      }
    }

    function formatArea(area) {
      if (currentUnit === 'metric') {
        return `${(area / 1000000).toFixed(2)} km¬≤`;
      } else {
        return `${(area / 2589988.11).toFixed(2)} mi¬≤`;
      }
    }

    // Slope Analysis Implementation
    function activateSlopeAnalysis() {
      map.getContainer().style.cursor = 'crosshair';

      const instruction = L.control({ position: 'topright' });
      instruction.onAdd = function () {
        const div = L.DomUtil.create('div', 'instruction-control');
        div.innerHTML = 'Click two points to calculate slope';
        div.style.background = 'white';
        div.style.padding = '10px';
        div.style.borderRadius = '5px';
        div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        return div;
      };
      instruction.addTo(map);

      let firstPoint = null;

      function onMapClick(e) {
        if (!firstPoint) {
          firstPoint = e.latlng;
          L.marker(firstPoint).addTo(map);
          instruction._div.innerHTML = 'Click second point';
        } else {
          const secondPoint = e.latlng;
          L.marker(secondPoint).addTo(map);

          // For demonstration, we'll calculate a mock slope
          // In reality, you'd need elevation data
          const distance = firstPoint.distanceTo(secondPoint);
          const elevationChange = Math.random() * 100 - 50; // Mock elevation change
          const slope = (elevationChange / distance) * 100;

          L.polyline([firstPoint, secondPoint], {
            color: 'purple',
            weight: 3
          }).addTo(map);

          const popup = L.popup()
            .setLatLng(secondPoint)
            .setContent(`
                <div>
                  <strong>Distance:</strong> ${(distance / 1000).toFixed(2)} km<br>
                  <strong>Elevation Change:</strong> ${elevationChange.toFixed(1)} m<br>
                  <strong>Slope:</strong> ${slope.toFixed(2)}%
                </div>
              `)
            .openOn(map);

          map.removeControl(instruction);
          map.off('click', onMapClick);
          map.getContainer().style.cursor = '';
        }
      }

      map.on('click', onMapClick);
    }

    // Helper Functions
    function updateUtilityToolButton(toolName) {
      const button = document.querySelector(`[onclick*="${toolName}"]`);
      if (button) {
        if (utilityToolsState[toolName]) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      }
    }

    function deactivateAllUtilityTools() {
      // Clear any active temporary tools
      if (bearingLine) {
        map.removeLayer(bearingLine);
        bearingLine = null;
      }

      distanceCircles.forEach(circle => map.removeLayer(circle));
      distanceCircles = [];

      map.getContainer().style.cursor = '';
    }

    // Add this JavaScript code before the closing </script> tag
  document.addEventListener('DOMContentLoaded', function() {
  const navbar = document.querySelector('.navbar');
  const navbarContent = document.querySelector('.navbar-content');
  const overflowToggle = document.querySelector('.navbar-overflow-toggle');

  // Toggle navbar expansion
  if (overflowToggle) {
  overflowToggle.addEventListener('click', function() {
  navbar.classList.toggle('expanded');
  navbarContent.classList.toggle('expanded');
  this.classList.toggle('active');
  });
  }

  // Handle dropdowns
  const dropdowns = document.querySelectorAll('.dropdown');
  dropdowns.forEach(dropdown => {
  const toggle = dropdown.querySelector('.dropdown-toggle');
  const menu = dropdown.querySelector('.dropdown-menu');

  if (toggle && menu) {
  toggle.addEventListener('click', function(e) {
  e.stopPropagation();
  menu.classList.toggle('show');
  });
  }
  });

  // Close dropdowns when clicking outside
  document.addEventListener('click', function(e) {
  if (!e.target.closest('.dropdown')) {
  document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
  menu.classList.remove('show');
  });
  }
  });

  // Handle window resize
  let resizeTimer;
  window.addEventListener('resize', function() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function() {
  const isExpanded = navbar.classList.contains('expanded');
  if (isExpanded) {
  navbar.classList.remove('expanded');
  navbarContent.classList.remove('expanded');
  if (overflowToggle) {
  overflowToggle.classList.remove('active');
  }
  }
  }, 250);
  });
  });

  // Advanced Tools Implementation
  let legendControl = null;
  let elevationMarker = null;
  let bufferLayer = null;
  let intersectionMarkers = [];

  function toggleAdvancedTools() {
  const menu = document.querySelector('.advanced-tools-menu');
  menu.classList.toggle('show');
  }

  // Close advanced tools menu when clicking outside
  document.addEventListener('click', function(e) {
  if (!e.target.closest('.advanced-tools-dropdown')) {
  document.querySelector('.advanced-tools-menu').classList.remove('show');
  }
  });

  function findMyLocation() {
  if ("geolocation" in navigator) {
  map.locate({setView: true, maxZoom: 16});

  map.on('locationfound', function(e) {
  const radius = e.accuracy;

  L.marker(e.latlng).addTo(map)
  .bindPopup(`You are within ${radius.toFixed(0)} meters from this point`).openPopup();

  L.circle(e.latlng, radius).addTo(map);
  });

  map.on('locationerror', function(e) {
  alert("Location access denied. Please enable location services.");
  });
  } else {
  alert("Geolocation is not supported by your browser");
  }
  }

  function getPointElevation() {
  map.getContainer().style.cursor = 'crosshair';

  const instruction = L.control({ position: 'topright' });
  instruction.onAdd = function() {
  const div = L.DomUtil.create('div', 'instruction-control');
  div.innerHTML = 'Click on map to get elevation';
  div.style.background = 'white';
  div.style.padding = '10px';
  div.style.borderRadius = '5px';
  div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)' ; return div;
  };
  instruction.addTo(map);

  function onMapClick(e) {
  if (elevationMarker) {
  map.removeLayer(elevationMarker);
  }

  // Using OpenTopography API for elevation data
  fetch(`https://portal.opentopography.org/API/astergdem?demtype=ASTERGDEMV3&south=${e.latlng.lat}&north=${e.latlng.lat}&west=${e.latlng.lng}&east=${e.latlng.lng}&outputFormat=GTiff`)
  .then(response => response.json())
  .then(data => {
  const elevation = data.data[0];
  elevationMarker = L.marker(e.latlng).addTo(map)
  .bindPopup(`Elevation: ${elevation.toFixed(2)} meters`).openPopup();
  })
  .catch(error => {
  console.error('Error fetching elevation:', error);
  alert('Error fetching elevation data. Please try again.');
  });

  map.removeControl(instruction);
  map.off('click', onMapClick);
  map.getContainer().style.cursor = '';
  }

  map.on('click', onMapClick);
  }

  function findIntersections() {
  map.getContainer().style.cursor = 'crosshair';

  const instruction = L.control({ position: 'topright' });
  instruction.onAdd = function() {
  const div = L.DomUtil.create('div', 'instruction-control');
  div.innerHTML = 'Click to start drawing a line. Click again to finish.';
  div.style.background = 'white';
  div.style.padding = '10px';
  div.style.borderRadius = '5px';
  div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)' ; return div;
  };
  instruction.addTo(map);

  let linePoints = [];
  let currentLine = null;

  function onMapClick(e) {
  linePoints.push(e.latlng);

  if (linePoints.length === 1) {
  currentLine = L.polyline([e.latlng], {color: 'blue'}).addTo(map);
  instruction._div.innerHTML = 'Click to finish the line';
  } else {
  currentLine.setLatLngs(linePoints);

  // Find intersections with existing lines
  map.eachLayer(layer => {
  if (layer instanceof L.Polyline && layer !== currentLine) {
  const intersections = findLineIntersections(linePoints, layer.getLatLngs());
  intersections.forEach(point => {
  const marker = L.marker(point, {
  icon: L.divIcon({
  className: 'intersection-point',
  html: '<div style="background: red; width: 10px; height: 10px; border-radius: 50%;"></div>',
  iconSize: [10, 10],
  iconAnchor: [5, 5]
  })
  }).addTo(map)
  .bindPopup('Intersection Point');
  intersectionMarkers.push(marker);
  });
  }
  });

  map.removeControl(instruction);
  map.off('click', onMapClick);
  map.getContainer().style.cursor = '';
  }
  }

  map.on('click', onMapClick);
  }

  function findLineIntersections(line1, line2) {
  const intersections = [];
  for (let i = 0; i < line1.length - 1; i++) { for (let j=0; j < line2.length - 1; j++) { const
    intersection=findIntersection( line1[i], line1[i + 1], line2[j], line2[j + 1] ); if (intersection) {
    intersections.push(intersection); } } } return intersections; } function findIntersection(p1, p2, p3, p4) { const
    x1=p1.lng, y1=p1.lat; const x2=p2.lng, y2=p2.lat; const x3=p3.lng, y3=p3.lat; const x4=p4.lng, y4=p4.lat; const
    denominator=(y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1); if (denominator===0) return null; const ua=((x4 - x3) *
    (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator; const ub=((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) /
    denominator; if (ua>= 0 && ua <= 1 && ub>= 0 && ub <= 1) { const x=x1 + ua * (x2 - x1); const y=y1 + ua * (y2 - y1);
        return L.latLng(y, x); } return null; } function performBufferAnalysis() {
        map.getContainer().style.cursor='crosshair' ; const instruction=L.control({ position: 'topright' });
        instruction.onAdd=function() { const div=L.DomUtil.create('div', 'instruction-control' );
        div.innerHTML='Click on map to create buffer' ; div.style.background='white' ; div.style.padding='10px' ;
        div.style.borderRadius='5px' ; div.style.boxShadow='0 2px 5px rgba(0,0,0,0.2)' ; return div; };
        instruction.addTo(map); function onMapClick(e) { if (bufferLayer) { map.removeLayer(bufferLayer); } const
        bufferRadius=1000; // 1km buffer bufferLayer=L.circle(e.latlng, { radius: bufferRadius, color: 'red' ,
        fillColor: '#f03' , fillOpacity: 0.2 }).addTo(map); // Add buffer info popup L.popup() .setLatLng(e.latlng)
        .setContent(`Buffer radius: ${(bufferRadius/1000).toFixed(1)} km`) .openOn(map); map.removeControl(instruction);
        map.off('click', onMapClick); map.getContainer().style.cursor='' ; } map.on('click', onMapClick); } function
        toggleLegend() { if (legendControl) { map.removeControl(legendControl); legendControl=null; } else {
        legendControl=L.control({ position: 'bottomright' }); legendControl.onAdd=function() { const
        div=L.DomUtil.create('div', 'legend-control' ); div.innerHTML=` <h4>Map Legend</h4>
        <div class="legend-item">
          <div class="legend-color" style="background: #3388ff;"></div>
          <div class="legend-label">Base Map</div>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #ff0000;"></div>
          <div class="legend-label">Buffer Zone</div>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #00ff00;"></div>
          <div class="legend-label">Intersection Points</div>
        </div>
        `;
        return div;
        };

        legendControl.addTo(map);
        }
        }

        // Navbar Toggle Functionality
        document.addEventListener('DOMContentLoaded', function() {
        const navbar = document.getElementById('navbar');
        const navbarContent = document.getElementById('navbarContent');
        const navbarToggle = document.getElementById('navbarToggle');
        const toggleIcon = navbarToggle.querySelector('i');
        const navbarGroups = navbarContent.querySelectorAll('.navbar-group');

        // Function to check which items should be hidden
        function checkNavbarOverflow() {
        const navbarWidth = navbarContent.offsetWidth;
        const toggleWidth = navbarToggle.offsetWidth + 20; // Add some margin
        let currentWidth = 0;
        let visibleCount = 0;

        navbarGroups.forEach((group, index) => {
        const groupWidth = group.offsetWidth;
        currentWidth += groupWidth;

        if (currentWidth <= navbarWidth - toggleWidth) { group.classList.remove('overflow-item'); visibleCount++; } else
          { group.classList.add('overflow-item'); } }); // Show/hide toggle button based on overflow
          navbarToggle.style.display=visibleCount < navbarGroups.length ? 'flex' : 'none' ; }
          navbarToggle.addEventListener('click', function() { navbar.classList.toggle('expanded');
          navbarContent.classList.toggle('expanded'); navbarToggle.classList.toggle('active');
          toggleIcon.classList.toggle('fa-chevron-down'); toggleIcon.classList.toggle('fa-chevron-up'); }); // Close
          expanded navbar when clicking outside document.addEventListener('click', function(event) { if
          (!navbar.contains(event.target) && navbar.classList.contains('expanded')) {
          navbar.classList.remove('expanded'); navbarContent.classList.remove('expanded');
          navbarToggle.classList.remove('active'); toggleIcon.classList.remove('fa-chevron-up');
          toggleIcon.classList.add('fa-chevron-down'); } }); // Check overflow on load and resize
          window.addEventListener('resize', checkNavbarOverflow); checkNavbarOverflow(); }); // Reverse Geocoding
          Implementation window.performReverseGeocoding=function() { if (!map) { console.error("Map not initialized");
          return; } map.getContainer().style.cursor='crosshair' ; const instruction=L.control({ position: 'topright' });
          instruction.onAdd=function() { const div=L.DomUtil.create('div', 'instruction-control' );
          div.innerHTML='Click on map to get address information' ; div.style.background='white' ;
          div.style.padding='10px' ; div.style.borderRadius='5px' ; div.style.boxShadow='0 2px 5px rgba(0,0,0,0.2)' ;
          return div; }; instruction.addTo(map); function onMapClick(e) { const { lat, lng }=e.latlng; // Using
          Nominatim for reverse geocoding with proper headers
          fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`,
          { headers: { 'Accept' : 'application/json' , 'User-Agent' : 'Geoportal/1.0' } }) .then(response=> {
          if (!response.ok) {
          throw new Error('Network response was not ok');
          }
          return response.json();
          })
          .then(data => {
          // Create marker with popup
          const marker = L.marker([lat, lng]).addTo(map);

          // Format address information
          const address = data.display_name || 'Address not found';
          const details = data.address || {};
          let popupContent = `
          <div class="reverse-geocoding-popup">
            <strong>Address:</strong><br>
            ${address}<br><br>
            <strong>Details:</strong><br>
            `;

            // Add address components if available
            if (details) {
            if (details.road) popupContent += `Road: ${details.road}<br>`;
            if (details.house_number) popupContent += `House Number: ${details.house_number}<br>`;
            if (details.suburb) popupContent += `Suburb: ${details.suburb}<br>`;
            if (details.city) popupContent += `City: ${details.city}<br>`;
            if (details.state) popupContent += `State: ${details.state}<br>`;
            if (details.country) popupContent += `Country: ${details.country}<br>`;
            if (details.postcode) popupContent += `Postcode: ${details.postcode}<br>`;
            }

            popupContent += '
          </div>';

          marker.bindPopup(popupContent).openPopup();
          })
          .catch(error => {
          console.error('Error fetching address:', error);
          alert('Error fetching address information. Please try again.');
          });

          map.removeControl(instruction);
          map.off('click', onMapClick);
          map.getContainer().style.cursor = '';
          }

          map.on('click', onMapClick);
          };

          // Add this at the end of your script section, before the closing </script> tag
          document.addEventListener('DOMContentLoaded', function() {
          // Add event listener for reverse geocoding button
          const reverseGeocodingBtn = document.getElementById('reverseGeocodingBtn');
          if (reverseGeocodingBtn) {
          reverseGeocodingBtn.addEventListener('click', function() {
          if (!map) {
          console.error("Map not initialized");
          return;
          }

          map.getContainer().style.cursor = 'crosshair';

          const instruction = L.control({ position: 'topright' });
          instruction.onAdd = function() {
          const div = L.DomUtil.create('div', 'instruction-control');
          div.innerHTML = 'Click on map to get address information';
          div.style.background = 'white';
          div.style.padding = '10px';
          div.style.borderRadius = '5px';
          div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
          return div;
          };
          instruction.addTo(map);

          function onMapClick(e) {
          const { lat, lng } = e.latlng;

          // Using Nominatim for reverse geocoding with proper headers
          fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`,
          {
          headers: {
          'Accept': 'application/json',
          'User-Agent': 'Geoportal/1.0'
          }
          })
          .then(response => {
          if (!response.ok) {
          throw new Error('Network response was not ok');
          }
          return response.json();
          })
          .then(data => {
          // Create marker with popup
          const marker = L.marker([lat, lng]).addTo(map);

          // Format address information
          const address = data.display_name || 'Address not found';
          const details = data.address || {};
          let popupContent = `
          <div class="reverse-geocoding-popup">
            <strong>Address:</strong><br>
            ${address}<br><br>
            <strong>Details:</strong><br>
            `;

            // Add address components if available
            if (details) {
            if (details.road) popupContent += `Road: ${details.road}<br>`;
            if (details.house_number) popupContent += `House Number: ${details.house_number}<br>`;
            if (details.suburb) popupContent += `Suburb: ${details.suburb}<br>`;
            if (details.city) popupContent += `City: ${details.city}<br>`;
            if (details.state) popupContent += `State: ${details.state}<br>`;
            if (details.country) popupContent += `Country: ${details.country}<br>`;
            if (details.postcode) popupContent += `Postcode: ${details.postcode}<br>`;
            }

            popupContent += '
          </div>';

          marker.bindPopup(popupContent).openPopup();
          })
          .catch(error => {
          console.error('Error fetching address:', error);
          alert('Error fetching address information. Please try again.');
          });

          map.removeControl(instruction);
          map.off('click', onMapClick);
          map.getContainer().style.cursor = '';
          }

          map.on('click', onMapClick);
          });
          }
          });

          // Export Functions
          function exportMapAsImage(format) {
          if (!map) {
          alert("Map not initialized");
          return;
          }

          // Create a temporary container for the map
          const container = document.createElement('div');
          container.style.width = map.getSize().x + 'px';
          container.style.height = map.getSize().y + 'px';
          container.style.position = 'absolute';
          container.style.left = '-9999px';
          document.body.appendChild(container);

          // Clone the map container
          const mapClone = map.getContainer().cloneNode(true);
          container.appendChild(mapClone);

          // Use html2canvas to capture the map
          html2canvas(mapClone, {
          useCORS: true,
          allowTaint: true,
          backgroundColor: null,
          scale: 2 // Higher quality
          }).then(canvas => {
          // Convert to image
          const imgData = canvas.toDataURL(`image/${format}`);

          // Create download link
          const link = document.createElement('a');
          link.download = `map-export.${format}`;
          link.href = imgData;
          link.click();

          // Cleanup
          document.body.removeChild(container);
          }).catch(error => {
          console.error('Error exporting map:', error);
          alert('Error exporting map. Please try again.');
          });
          }

          function exportFeatures(format) {
          console.log('Starting feature export...');
          console.log('Map:', map);
          console.log('Drawn Items:', drawnItems);

          if (!map) {
          alert("Map not initialized");
          return;
          }

          if (!drawnItems) {
          console.log('No drawnItems found, checking for drawn items in map...');
          // Try to find drawn items in the map
          const layers = map._layers;
          let foundDrawnItems = null;

          for (let key in layers) {
          if (layers[key] instanceof L.FeatureGroup) {
          foundDrawnItems = layers[key];
          break;
          }
          }

          if (!foundDrawnItems) {
          alert("No drawing layer found. Please draw some features first.");
          return;
          }
          drawnItems = foundDrawnItems;
          }

          console.log('Getting GeoJSON from drawn items...');
          const features = drawnItems.toGeoJSON();
          console.log('Features:', features);

          if (!features || !features.features || features.features.length === 0) {
          alert("No features selected. Please draw some features first.");
          return;
          }

          let data, mimeType, extension;
          try {
          switch (format) {
          case 'geojson':
          console.log('Exporting as GeoJSON...');
          data = JSON.stringify(features, null, 2);
          mimeType = 'application/json';
          extension = 'geojson';
          break;
          case 'kml':
          console.log('Exporting as KML...');
          data = toKML(features);
          mimeType = 'application/vnd.google-earth.kml+xml';
          extension = 'kml';
          break;
          case 'shapefile':
          alert("Shapefile export requires server-side processing. This feature is not available in the browser
          version.");
          return;
          default:
          alert("Unsupported format");
          return;
          }

          console.log('Creating download...');
          // Create download link
          const blob = new Blob([data], { type: mimeType });
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `map-features.${extension}`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);

          console.log('Export completed successfully');
          } catch (error) {
          console.error('Error during export:', error);
          alert('Error exporting features: ' + error.message);
          }
          }

          function toKML(geojson) {
          console.log('Converting to KML...');
          let kml = '
          <?xml version="1.0" encoding="UTF-8"?>\n';
          kml += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
            kml += '<Document>\n';

              geojson.features.forEach((feature, index) => {
              console.log(`Processing feature ${index}:`, feature);

              if (feature.geometry.type === 'Point') {
              kml += '<Placemark>\n';
                kml += `<Point>\n<coordinates>${feature.geometry.coordinates.join(',')}</coordinates>\n</Point>\n`;
                kml += '</Placemark>\n';
              } else if (feature.geometry.type === 'LineString') {
              kml += '<Placemark>\n';
                kml += `<LineString>\n<coordinates>${feature.geometry.coordinates.map(coord => coord.join(',')).join('
                    ')}</coordinates>\n</LineString>\n`;
                kml += '</Placemark>\n';
              } else if (feature.geometry.type === 'Polygon') {
              kml += '<Placemark>\n';
                kml += `<Polygon>\n<outerBoundaryIs>\n<LinearRing>\n<coordinates>
                        ${feature.geometry.coordinates[0].map(coord => coord.join(',')).join(' ')}</coordinates>\n
                    </LinearRing>\n</outerBoundaryIs>\n</Polygon>\n`;
                kml += '</Placemark>\n';
              } else {
              console.warn(`Unsupported geometry type: ${feature.geometry.type}`);
              }
              });

              kml += '</Document>\n</kml>';
          console.log('KML conversion completed');
          return kml;
          }

          function shareMapView() {
          if (!map) {
          alert("Map not initialized");
          return;
          }

          const center = map.getCenter();
          const zoom = map.getZoom();
          const url =
          `${window.location.origin}${window.location.pathname}?lat=${center.lat}&lng=${center.lng}&zoom=${zoom}`;

          // Create a temporary input element
          const input = document.createElement('input');
          input.value = url;
          document.body.appendChild(input);
          input.select();

          try {
          // Try using the modern clipboard API
          navigator.clipboard.writeText(url).then(() => {
          alert('Map view URL copied to clipboard!');
          }).catch(() => {
          // Fallback to execCommand
          document.execCommand('copy');
          alert('Map view URL copied to clipboard!');
          });
          } catch (error) {
          console.error('Error copying to clipboard:', error);
          alert('Error copying URL. Please copy it manually: ' + url);
          }

          document.body.removeChild(input);
          }

          function generatePDFReport() {
          if (!map) {
          alert("Map not initialized");
          return;
          }

          // Create a temporary container for the report
          const container = document.createElement('div');
          container.style.width = '800px';
          container.style.padding = '20px';
          document.body.appendChild(container);

          // Get the legend HTML (if visible)
          let legendHTML = "";
          const legendContent = document.getElementById("legendContent");
          if (legendContent && legendContent.innerHTML.trim() !== "") {
          legendHTML = `<div style="margin-top:20px;">
            <h3>Legend</h3>${legendContent.innerHTML}
          </div>`;
          } else {
          // Fallback static legend
          legendHTML = `
          <div style="margin-top:20px;">
            <h3>Legend</h3>
            <div class="legend-item"><span
                style="display:inline-block;width:20px;height:3px;background:#ff6b6b;margin-right:10px;border-radius:2px;"></span>India
              Boundary</div>
            <div class="legend-item"><span
                style="display:inline-block;width:20px;height:3px;background:#4ecdc4;margin-right:10px;border-radius:2px;"></span>Maharashtra
              Boundary</div>
            <div class="legend-item"><span
                style="display:inline-block;width:20px;height:3px;background:#45b7d1;margin-right:10px;border-radius:2px;"></span>District
              Boundary</div>
            <!-- Add more as needed -->
          </div>
          `;
          }

          // North arrow SVG
          const northArrowSVG = `
          <div style="margin-top:20px;display:flex;align-items:center;">
            <svg width="40" height="60" viewBox="0 0 40 60">
              <polygon points="20,5 30,40 20,35 10,40" style="fill:#333;stroke:#222;stroke-width:2" />
              <text x="20" y="55" text-anchor="middle" font-size="18" fill="#222" font-family="Arial">N</text>
            </svg>
            <span style="margin-left:10px;font-size:14px;">North</span>
          </div>
          `;

          // Static scale bar SVG (for visual effect)
          const scaleBarSVG = `
          <div style="margin-top:10px;">
            <svg width="120" height="30">
              <rect x="10" y="10" width="100" height="10" fill="#222" />
              <rect x="10" y="10" width="50" height="10" fill="#fff" />
              <text x="10" y="28" font-size="12" fill="#222">0</text>
              <text x="60" y="28" font-size="12" fill="#222">500 m</text>
              <text x="110" y="28" font-size="12" fill="#222">1 km</text>
            </svg>
          </div>
          `;

          // Capture map as image
          html2canvas(map.getContainer(), {
          useCORS: true,
          allowTaint: true,
          backgroundColor: null,
          scale: 2 // Higher quality
          }).then(canvas => {
          // Create report content
          const report = document.createElement('div');
          report.innerHTML = `
          <h2>Map Report</h2>
          <p>Generated on: ${new Date().toLocaleString()}</p>
          <p>Center: ${map.getCenter().lat.toFixed(6)}, ${map.getCenter().lng.toFixed(6)}</p>
          <p>Zoom Level: ${map.getZoom()}</p>
          <img src="${canvas.toDataURL()}" style="width: 100%; margin: 20px 0;">
          ${legendHTML}
          ${northArrowSVG}
          ${scaleBarSVG}
          <h3>Active Layers:</h3>
          <ul>
            ${Object.keys(overlayLayers).map(layer => `<li>${layer}</li>`).join('')}
          </ul>
          `;
          container.appendChild(report);

          // Generate PDF
          const opt = {
          margin: 1,
          filename: 'map-report.pdf',
          image: { type: 'jpeg', quality: 0.98 },
          html2canvas: { scale: 2 },
          jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }
          };

          html2pdf().set(opt).from(container).save();

          // Cleanup
          document.body.removeChild(container);
          }).catch(error => {
          console.error('Error generating PDF:', error);
          alert('Error generating PDF report. Please try again.');
          });
          }

          // Add required libraries
          const html2canvasScript = document.createElement('script');
          html2canvasScript.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
          document.head.appendChild(html2canvasScript);

          const html2pdfScript = document.createElement('script');
          html2pdfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js';
          document.head.appendChild(html2pdfScript);

          // CAD Import Functionality
          window.handleCADFile = function(event) {
          const file = event.target.files[0];
          if (!file) return;

          // Show loading state
          const loadingControl = L.control({ position: 'topright' });
          loadingControl.onAdd = function() {
          const div = L.DomUtil.create('div', 'loading-control');
          div.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading CAD file...';
          div.style.background = 'white';
          div.style.padding = '10px';
          div.style.borderRadius = '5px';
          div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
          return div;
          };
          loadingControl.addTo(map);

          const reader = new FileReader();
          reader.onload = function(e) {
          try {
          const dxfContent = e.target.result;
          const parser = new DxfParser();
          const dxf = parser.parseSync(dxfContent);

          // Convert DXF to GeoJSON
          const converter = new L.DXF();
          const geojson = converter.convert(dxf);

          // Create a layer group for the CAD elements
          const cadLayer = L.geoJSON(geojson, {
          style: function(feature) {
          // Style based on layer name
          const layerName = feature.properties.layer;
          return {
          color: getLayerColor(layerName),
          weight: 2,
          opacity: 0.8,
          fillOpacity: 0.2
          };
          },
          onEachFeature: function(feature, layer) {
          // Add popup with CAD element information
          if (feature.properties) {
          const popupContent = `
          <div class="cad-popup">
            <h4>CAD Element</h4>
            <p><strong>Layer:</strong> ${feature.properties.layer || 'Unknown'}</p>
            <p><strong>Type:</strong> ${feature.geometry.type}</p>
            ${feature.properties.handle ? `<p><strong>Handle:</strong> ${feature.properties.handle}</p>` : ''}
            ${feature.properties.color ? `<p><strong>Color:</strong> ${feature.properties.color}</p>` : ''}
          </div>
          `;
          layer.bindPopup(popupContent);
          }
          }
          }).addTo(map);

          // Fit map to layer bounds
          map.fitBounds(cadLayer.getBounds());

          // Add to layer control with layer groups
          const layerName = file.name.replace('.dxf', '');
          const layerGroups = {};

          // Group layers by their CAD layer names
          cadLayer.eachLayer(function(layer) {
          const layerName = layer.feature.properties.layer || 'Default';
          if (!layerGroups[layerName]) {
          layerGroups[layerName] = L.layerGroup();
          }
          layerGroups[layerName].addLayer(layer);
          });

          // Add each layer group to the control
          Object.keys(layerGroups).forEach(function(name) {
          layerControl.addOverlay(layerGroups[name], `${layerName} - ${name}`);
          });

          // Remove loading control
          map.removeControl(loadingControl);

          // Show success message
          showNotification('CAD file imported successfully!', 'success');
          } catch (error) {
          console.error('Error processing CAD file:', error);
          showNotification('Error processing CAD file. Please check the file format.', 'error');
          map.removeControl(loadingControl);
          }
          };
          reader.readAsText(file);
          };

          // Helper function to get consistent colors for CAD layers
          function getLayerColor(layerName) {
          const colors = {
          '0': '#000000', // Black
          '1': '#FF0000', // Red
          '2': '#FFFF00', // Yellow
          '3': '#00FF00', // Green
          '4': '#00FFFF', // Cyan
          '5': '#0000FF', // Blue
          '6': '#FF00FF', // Magenta
          '7': '#FFFFFF', // White
          '8': '#808080', // Gray
          '9': '#800000', // Dark Red
          '10': '#808000', // Dark Yellow
          '11': '#008000', // Dark Green
          '12': '#008080', // Dark Cyan
          '13': '#000080', // Dark Blue
          '14': '#800080', // Dark Magenta
          '15': '#C0C0C0' // Light Gray
          };

          // Use layer name as key or default to black
          return colors[layerName] || colors['0'];
          }

          // Helper function to show notifications
          function showNotification(message, type = 'info') {
          const notification = document.createElement('div');
          notification.className = `notification ${type}`;
          notification.textContent = message;
          document.body.appendChild(notification);

          setTimeout(() => {
          notification.remove();
          }, 3000);
          }

          // Add styles for notifications and CAD elements
          const style = document.createElement('style');
          style.textContent = `
          .notification {
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 15px 20px;
          border-radius: 5px;
          color: white;
          font-family: Arial, sans-serif;
          z-index: 1000;
          animation: slideIn 0.3s ease-out;
          }

          .notification.success {
          background-color: #4CAF50;
          }

          .notification.error {
          background-color: #f44336;
          }

          .notification.info {
          background-color: #2196F3;
          }

          @keyframes slideIn {
          from {
          transform: translateX(100%);
          opacity: 0;
          }
          to {
          transform: translateX(0);
          opacity: 1;
          }
          }

          .cad-popup {
          font-family: Arial, sans-serif;
          font-size: 12px;
          }

          .cad-popup h4 {
          margin: 0 0 8px 0;
          color: #333;
          font-size: 14px;
          }

          .cad-popup p {
          margin: 4px 0;
          color: #666;
          }

          .loading-control {
          font-family: Arial, sans-serif;
          font-size: 12px;
          color: #333;
          }

          .loading-control i {
          margin-right: 8px;
          color: #007bff;
          }
          `;
          document.head.appendChild(style);

          </script>
          <script>
            // Global variables

            let wmsLayerNames = {}; // To store friendly names for layers



            // --- New Info Panel Functionality ---
            function setupInfoButton() {
              const infoBtn = document.getElementById('info-btn');
              if (infoBtn) {
                // Replace any existing click handlers with our new function
                infoBtn.onclick = showAllFeatures;
              }
            }

            function closeInfoPanel() {
              document.getElementById('feature-info-panel').classList.remove('visible');
              if (highlightedFeatureLayer) {
                map.removeLayer(highlightedFeatureLayer);
                highlightedFeatureLayer = null;
              }
            }

            // --- REPLACE your entire showAllFeatures function with this ---
            function showAllFeatures() {
              console.log("showAllFeatures called to fetch data and build layers...");

              // Dynamically get the active WMS layer
              let activeLayerName = null;
              let activeWmsUrl = null;

              // Find the first visible WMS layer in overlayLayers
              for (const [name, layer] of Object.entries(overlayLayers)) {
                if (map.hasLayer(layer) && layer.wmsParams && layer.wmsParams.layers) {
                  activeLayerName = layer.wmsParams.layers;
                  activeWmsUrl = layer._url;
                  break;
                }
              }

              if (!activeLayerName || !activeWmsUrl) {
                document.getElementById('feature-list').innerHTML = '<p style="color:red;">No WMS layer is currently active.</p>';
                document.getElementById('feature-info-panel').classList.add('visible');
                return;
              }

              // Construct a WFS URL to get ALL features for the layer
              const wfsUrl = activeWmsUrl.replace('/wms', '/wfs');
              const params = [
                "service=WFS", "version=1.1.0", "request=GetFeature",
                `typeName=${encodeURIComponent(activeLayerName)}`,
                "outputFormat=application/json", "srsName=EPSG:4326"
              ].join("&");
              const proxyWfsUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(`${wfsUrl}?${params}`)}`;

              document.getElementById('feature-list').innerHTML = '<p>Loading features...</p>';
              document.getElementById('feature-info-panel').classList.add('visible');

              fetch(proxyWfsUrl, {
                headers: { 'ngrok-skip-browser-warning': 'true' }
              })
                .then(response => {
                  if (!response.ok) {
                    return response.text().then(text => { throw new Error(`Server Error: ${text}`); });
                  }
                  return response.json();
                })
                .then(data => {
                  const featureListDiv = document.getElementById('feature-list');
                  featureListDiv.innerHTML = '';

                  if (data.features && data.features.length > 0) {
                    // Populate the sidebar
                    data.features.forEach(feature => {
                      const item = document.createElement('div');
                      item.className = 'feature-item';
                      let content = '';
                      for (const [key, value] of Object.entries(feature.properties)) {
                        content += `<b>${key}:</b> ${value}<br>`;
                      }
                      item.innerHTML = content;
                      featureListDiv.appendChild(item);
                    });

                    // Build the OBJECTID lookup table
                    Object.keys(featureInfoById).forEach(key => delete featureInfoById[key]);
                    data.features.forEach(feature => {
                      if (feature.properties.OBJECTID) {
                        featureInfoById[feature.properties.OBJECTID] = feature.properties;
                      }
                    });

                    // Create the INVISIBLE vector layer for clicks
                    if (contourVectorLayer) {
                      map.removeLayer(contourVectorLayer);
                    }

                    contourVectorLayer = L.geoJSON(data, {
                      style: { opacity: 0, fillOpacity: 0, weight: 5 },
                      onEachFeature: function (feature, layer) {
                        layer.on('click', function (e) {
                          if (!infoToolActive) return;
                          L.DomEvent.stopPropagation(e);
                          const objId = feature.properties.OBJECTID;
                          const props = featureInfoById[objId] || feature.properties;
                          let popupContent = '<div style="max-height: 200px; overflow-y: auto;">';
                          Object.keys(props).forEach(key => {
                            popupContent += `<b>${key}:</b> ${props[key]}<br>`;
                          });
                          popupContent += "</div>";
                          L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map);
                        });
                      }
                    }).addTo(map);
                    console.log("SUCCESS: Clickable vector layer is now on the map.");
                  } else {
                    featureListDiv.innerHTML = '<p>No features found in this layer.</p>';
                  }
                })
                .catch(err => {
                  console.error("WFS fetch error:", err);
                  document.getElementById('feature-list').innerHTML = `<p style="color:red;">Error fetching feature data. Please check the console.</p>`;
                });
            }

            // 4. Update onEachFeature for GeoJSON/shapefile layers (find all L.geoJSON and similar, update onEachFeature)
            function showFeatureInSidebar(feature) {
              // Remove previous highlight
              if (highlightedFeatureLayer) {
                map.removeLayer(highlightedFeatureLayer);
                highlightedFeatureLayer = null;
              }
              // Highlight the clicked feature
              highlightedFeatureLayer = L.geoJSON(feature, {
                style: { color: 'cyan', weight: 5, opacity: 1.0, fillOpacity: 0.2 },
                pointToLayer: function (f, latlng) {
                  return L.circleMarker(latlng, { radius: 10, color: 'cyan', fillOpacity: 0.5 });
                }
              }).addTo(map);
              // Fill sidebar
              const featureListDiv = document.getElementById('feature-list');
              let content = '';
              for (const [key, value] of Object.entries(feature.properties)) {
                content += `<b>${key}:</b> ${value}<br>`;
              }
              featureListDiv.innerHTML = content;
              document.getElementById('feature-info-panel').classList.add('visible');
            }
          </script>

          <script>
            document.addEventListener('click', function (event) {
              const sidebar = document.getElementById('feature-info-panel');
              const infoBtn = document.getElementById('infoToolBtn');
              if (
                sidebar.classList.contains('visible') &&
                !sidebar.contains(event.target) &&
                event.target !== infoBtn
              ) {
                sidebar.classList.remove('visible');
                // Optionally, remove highlight from map
                if (highlightedFeatureLayer) {
                  map.removeLayer(highlightedFeatureLayer);
                  highlightedFeatureLayer = null;
                }
              }
            });
          </script>

          <!-- Attribute Table Modal -->
          <div id="attribute-table-modal"
            style="display:none; position:fixed; top:10%; left:50%; transform:translateX(-50%); width:80vw; max-width:900px; height:70vh; background:white; border-radius:10px; box-shadow:0 4px 20px rgba(0,0,0,0.3); z-index:3000; overflow:auto;">
            <div
              style="padding:10px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
              <span style="font-size:18px; font-weight:bold;">Attribute Table</span>
              <div style="display:flex; align-items:center; gap:10px;">
                <button id="get-attributes-btn" onclick="getAttributesAndMarkLoaded()" style="
                  background: #3498db;
                  color: #fff;
                  border: none;
                  border-radius: 5px;
                  padding: 6px 16px;
                  font-size: 14px;
                  font-weight: 500;
                  cursor: pointer;
                  transition: background 0.2s;
                  box-shadow: 0 2px 6px rgba(52,152,219,0.08);
                  display: flex;
                  align-items: center;
                  gap: 6px;
                " onmouseover="this.style.background='#217dbb'" onmouseout="this.style.background='#3498db'">
                  <i class="fas fa-table"></i> Get Attributes
                </button>
                <button onclick="closeAttributeTable()" style="
                  background:none;
                  border:none;
                  font-size:24px;
                  cursor:pointer;
                  color:#888;
                  margin-left:8px;
                  transition: color 0.2s;
                " onmouseover="this.style.color='#c00'" onmouseout="this.style.color='#888'">&times;</button>
              </div>
            </div>

            <div id="attribute-table-content" style="padding:10px; overflow:auto; max-height:60vh;"></div>
          </div>
          <div id="attribute-table-overlay"
            style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.3); z-index:2999;"
            onclick="closeAttributeTable()"></div>

          <!-- Helper to open/close the modal -->
          </script>




          <script>
            document.addEventListener('DOMContentLoaded', function () {
              const attrBtn = document.getElementById('attributeTableBtn');
              if (attrBtn) {
                attrBtn.onclick = openAttributeTable; // Only open, don't load data
              }
            });
          </script>

          <script>
            document.addEventListener('DOMContentLoaded', function () {
              const infoBtn = document.getElementById('infoToolBtn');
              if (infoBtn) {
                infoBtn.onclick = function (event) {
                  event.stopPropagation();

                  // Always remove the old vector layer so we refresh for the current WMS layer
                  if (contourVectorLayer) {
                    map.removeLayer(contourVectorLayer);
                    contourVectorLayer = null;
                  }

                  // Toggle the info tool state
                  infoToolActive = !infoToolActive;
                  console.log(`[Info Tool] Toggled. New state: ${infoToolActive}`);

                  if (infoToolActive) {
                    map.getContainer().style.cursor = 'help';
                    this.classList.add('active');
                    // Always load features for the current WMS layer
                    showAllFeatures();
                  } else {
                    map.getContainer().style.cursor = '';
                    this.classList.remove('active');
                    // Optionally, hide the sidebar or clear info
                    // document.getElementById('feature-info-panel').classList.remove('visible');
                  }
                };
              }
            });
          </script>

          <script>
            function openAttributeTable() {
              document.getElementById('attribute-table-modal').style.display = 'block';
              document.getElementById('attribute-table-overlay').style.display = 'block';
              if (!attributeTableLoaded) {
                showAttributeTable();
                attributeTableLoaded = true;
              }
            }
            function closeAttributeTable() {
              document.getElementById('attribute-table-modal').style.display = 'none';
              document.getElementById('attribute-table-overlay').style.display = 'none';
            }

            // Main function to build the attribute table
            function showAttributeTable() {
              attributeTableLoaded = true;
              let features = [];

              // 1. Try vector layers (GeoJSON/shapefile)
              if (typeof overlayLayers !== "undefined") {
                for (const [name, layer] of Object.entries(overlayLayers)) {
                  if (map.hasLayer(layer) && layer.toGeoJSON) {
                    features = layer.toGeoJSON().features;
                    break;
                  }
                }
              }

              // 2. If not found, try WMS vector layer (contourVectorLayer)
              if ((!features || features.length === 0) && typeof contourVectorLayer !== "undefined" && contourVectorLayer && map.hasLayer(contourVectorLayer)) {
                features = contourVectorLayer.toGeoJSON().features;
              }

              // 3. If still not found, try to fetch features for the current WMS layer using WFS
              if (!features || features.length === 0) {
                // Find the active WMS layer
                let activeLayerName = null;
                let activeWmsUrl = null;
                for (const [name, layer] of Object.entries(overlayLayers)) {
                  if (map.hasLayer(layer) && layer.wmsParams && layer.wmsParams.layers) {
                    activeLayerName = layer.wmsParams.layers;
                    activeWmsUrl = layer._url;
                    break;
                  }
                }
                if (activeLayerName && activeWmsUrl) {
                  // Build WFS URL
                  const wfsUrl = activeWmsUrl.replace('/wms', '/wfs');
                  const params = [
                    "service=WFS", "version=1.1.0", "request=GetFeature",
                    `typeName=${encodeURIComponent(activeLayerName)}`,
                    "outputFormat=application/json", "srsName=EPSG:4326"
                  ].join("&");
                  const proxyWfsUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(`${wfsUrl}?${params}`)}`;

                  document.getElementById('attribute-table-content').innerHTML = '<p>Loading features...</p>';

                  fetch(proxyWfsUrl, {
                    headers: { 'ngrok-skip-browser-warning': 'true' }
                  })
                    .then(response => {
                      if (!response.ok) {
                        return response.text().then(text => { throw new Error(`Server Error: ${text}`); });
                      }
                      return response.json();
                    })
                    .then(data => {
                      if (data.features && data.features.length > 0) {
                        buildAttributeTable(data.features);
                      } else {
                        document.getElementById('attribute-table-content').innerHTML = '<p>No features found for the current layer.</p>';
                      }
                    })
                    .catch(err => {
                      document.getElementById('attribute-table-content').innerHTML = `<p style="color:red;">Error fetching feature data. Please check the console.</p>`;
                      console.error(err);
                    });
                  return;
                }
              }

              // If features found, build the table
              if (features && features.length > 0) {
                buildAttributeTable(features);
              } else {
                document.getElementById('attribute-table-content').innerHTML = '<p>No features found for the current layer.</p>';
              }
            }

            // Helper to build the table
            function buildAttributeTable(features) {
              const allKeys = Array.from(new Set(features.flatMap(f => Object.keys(f.properties))));
              let html = '<table border="1" style="border-collapse:collapse; min-width:1200px; width:max-content; font-size:13px;">';
              html += '<thead><tr>' + allKeys.map(k => `<th style="padding:4px 8px; background:#f5f5f5;">${k}</th>`).join('') + '</tr></thead>';
              html += '<tbody>';
              features.forEach((f, idx) => {
                html += `<tr style="cursor:pointer;" onclick="highlightFeatureFromTable(${idx})">` +
                  allKeys.map(k => `<td style="padding:4px 8px;">${f.properties[k] !== undefined ? f.properties[k] : ''}</td>`).join('') +
                  '</tr>';
              });
              html += '</tbody></table>';

              document.getElementById('attribute-table-content').innerHTML = html;

              // Store features for row click highlighting
              window._attributeTableFeatures = features;
            }

            // Highlight feature on map when row is clicked
            function highlightFeatureFromTable(idx) {
              if (window._attributeTableHighlight) {
                map.removeLayer(window._attributeTableHighlight);
              }
              const feature = window._attributeTableFeatures[idx];
              window._attributeTableHighlight = L.geoJSON(feature, {
                style: { color: 'orange', weight: 5, fillOpacity: 0.2 },
                pointToLayer: (f, latlng) => L.circleMarker(latlng, { radius: 10, color: 'orange', fillOpacity: 0.5 })
              }).addTo(map);
              // Zoom to feature
              if (feature.geometry.type === 'Point') {
                map.setView([feature.geometry.coordinates[1], feature.geometry.coordinates[0]], 16);
              } else {
                try {
                  map.fitBounds(window._attributeTableHighlight.getBounds());
                } catch (e) { }
              }
            }

            document.addEventListener('DOMContentLoaded', function () {
              const attrBtn = document.getElementById('attributeTableBtn');
              if (attrBtn) {
                attrBtn.onclick = openAttributeTable;
              }
            });
          </script>

          <script>
            const wmsLayerZoomLevels = {
              "india_boundary": 6, // Not in your list, but you can add if needed
              "maharashtra_boundary": 7,
              "division_boundary": 7,
              "district_boundary": 7,
              "taluka_boundary": 7,
              "village_boundary": 7,
              "hq_tal_dist_div": 13,
              "tuljapur_taluka": 16,
              "tuljapur_village": 14,
              "tuljapur_municipal_council": 16,
              "tuljabhavani_temple_trust": 17,
              "tuljabhavani_temple_complex": 18,
              "drone_based_contour": 16,
              "drone_based_masterplan": 15,
              "monument_locations": 17
            };
          </script>

          <script>
            function getAttributesAndMarkLoaded() {
              showAttributeTable();
              attributeTableLoaded = true;
            }
          </script>

          // Clear Advanced Tools
          window.clearAdvancedTools = function() {
          if (advancedToolsLayerGroup) {
          advancedToolsLayerGroup.clearLayers();
          }
          if (legendControl) {
          map.removeControl(legendControl);
          legendControl = null;
          }
          // Reset local tracking variables
          userLocationMarker = null;
          elevationMarker = null;
          intersectionMarkers = [];
          bufferLayer = null;
          };

          // Add styles for the new features
          </script>

          <script>
            window.toggleUtilityTool = toggleUtilityTool;
            window.toggleMousePosition = toggleMousePosition;
            window.addMousePosition = addMousePosition;
            window.removeMousePosition = removeMousePosition;
          </script>

          <script>
            function restoreBasemap() {
              if (typeof currentBasemap !== "undefined" && !map.hasLayer(currentBasemap)) {
                map.addLayer(currentBasemap);
              }
              document.getElementById('map').style.background = "";
            }
          </script>

          <script>
            function getUTMZoneFromLng(lng) {
              return Math.floor((lng + 180) / 6) + 1;
            }
          </script>

          <div id="north-arrow">
            <svg viewBox="0 0 48 70" width="40" height="54">
              <defs>
                <radialGradient id="arrowGradient" cx="50%" cy="40%" r="80%">
                  <stop offset="0%" stop-color="#fffbe6" />
                  <stop offset="100%" stop-color="#c19a6b" />
                </radialGradient>
              </defs>
              <polygon points="24,8 38,50 24,40 10,50" fill="url(#arrowGradient)" stroke="#2e1a0e" stroke-width="2" />
              <text x="24" y="60" text-anchor="middle" font-size="15" fill="#2e1a0e" font-family="Georgia"
                font-weight="bold">N</text>
            </svg>
          </div>

          <script>
            function showWMSLabels(layerName, wmsUrl, logicalLayerKey) {
              console.log("=== showWMSLabels FIXED VERSION ===");
              console.log("showWMSLabels called with:", layerName, wmsUrl, logicalLayerKey);
              const wmsLayerLabelZoomLevels = {
                "india_boundary": 6,
                "maharashtra_boundary": 7,
                "division_boundary": 7,
                "district_boundary": 7,
                "taluka_boundary": 7,
                "village_boundary": 7,
                "hq_tal_dist_div": 13,
                "tuljapur_taluka": 16,
                "tuljapur_village": 14,
                "tuljapur_municipal_council": 16,
                "tuljabhavani_temple_trust": 17,
                "tuljabhavani_temple_complex": 18,
                "drone_based_contour": 16,
                "drone_based_masterplan": 15,
                "monument_locations": 17
              };

              if (typeof PROXY_URL === 'undefined') {
                console.error("ERROR: PROXY_URL is not defined!");
                return;
              }

              if (typeof map === 'undefined' || typeof map.getBounds !== 'function') {
                console.error("ERROR: map object or getBounds method not available!");
                return;
              }

              if (window._wmsLabelLayer && map.hasLayer(window._wmsLabelLayer)) {
                map.removeLayer(window._wmsLabelLayer);
              }

              // Use the same WFS URL construction as the info tool, but for the map bounds
              const bounds = map.getBounds();
              const wfsUrl = wmsUrl.replace('/wms', '/wfs');
              const params = [
                "service=WFS",
                "version=1.1.0",
                "request=GetFeature",
                `typeName=${encodeURIComponent(layerName)}`,
                "outputFormat=application/json",
                "srsName=EPSG:4326"
                // Optionally: "maxFeatures=1000"
              ].join("&");
              const proxyWfsUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(`${wfsUrl}?${params}`)}`;
              console.log("WFS URL for labels:", proxyWfsUrl);

              fetch(proxyWfsUrl, {
                headers: { 'ngrok-skip-browser-warning': 'true' }
              })
                .then(response => response.json())
                .then(data => {
                  if (data.features && data.features.length > 0) {
                    createLabelsFromData(data, logicalLayerKey);
                  } else {
                    console.log("No features found for labels.");
                  }
                })
                .catch(error => {
                  console.error("Error fetching WFS features for labels:", error);
                });

              // Create labels from successful data
              function createLabelsFromData(data, logicalLayerKey) {


                const labelLayer = L.layerGroup();
                let labelsCreated = 0;

                data.features.forEach((feature, index) => {
                  const props = feature.properties;


                  // Try multiple property names for the label
                  const name = props.NAME || props.name || props.Name ||
                    props.DISTRICT || props.STATE || props.VILLAGE ||
                    props.TALUKA || props.admin_name || props.label ||
                    `Feature ${index + 1}`;

                  // Calculate centroid
                  let latlng = null;
                  try {
                    if (feature.geometry.type === "Polygon") {
                      latlng = getPolygonCentroid ? getPolygonCentroid(feature.geometry.coordinates[0]) :
                        getSimpleCentroid(feature.geometry.coordinates[0]);
                    } else if (feature.geometry.type === "MultiPolygon") {
                      latlng = getPolygonCentroid ? getPolygonCentroid(feature.geometry.coordinates[0][0]) :
                        getSimpleCentroid(feature.geometry.coordinates[0][0]);
                    } else if (feature.geometry.type === "Point") {
                      latlng = { lat: feature.geometry.coordinates[1], lng: feature.geometry.coordinates[0] };
                    }
                  } catch (error) {
                    console.error(`Error calculating centroid for feature ${index + 1}:`, error);
                  }

                  if (latlng && name) {
                    const label = L.marker([latlng.lat, latlng.lng], {
                      icon: L.divIcon({
                        className: 'wms-label',
                        html: `<span style="background:rgba(255,255,255,0.9);padding:3px 8px;border-radius:4px;font-size:12px;color:#2e1a0e;font-weight:bold;border:1px solid #c19a6b;box-shadow:0 1px 3px rgba(0,0,0,0.3);">${name}</span>`,
                        iconSize: [120, 28],
                        iconAnchor: [60, 14]
                      }),
                      interactive: false
                    });
                    labelLayer.addLayer(label);
                    labelsCreated++;
                    console.log(`Created label ${labelsCreated}: "${name}" at [${latlng.lat}, ${latlng.lng}]`);
                  }
                });

                if (labelsCreated > 0) {
                  window._wmsLabelLayer = labelLayer;
                  window._wmsLabelLayerKey = logicalLayerKey;

                  // Add to map
                  if (typeof updateWMSLabelVisibility === 'function') {
                    updateWMSLabelVisibility();
                  } else {
                    map.addLayer(labelLayer);
                    console.log(`Added ${labelsCreated} labels directly to map`);
                  }

                  // Listen for zoom changes (only once)
                  if (!window._wmsLabelZoomListener) {
                    map.on('zoomend', updateWMSLabelVisibility || function () {
                      // Fallback zoom handler
                      if (map.getZoom() >= 8) {
                        if (window._wmsLabelLayer && !map.hasLayer(window._wmsLabelLayer)) {
                          map.addLayer(window._wmsLabelLayer);
                        }
                      } else {
                        if (window._wmsLabelLayer && map.hasLayer(window._wmsLabelLayer)) {
                          map.removeLayer(window._wmsLabelLayer);
                        }
                      }
                    });
                    window._wmsLabelZoomListener = true;
                  }

                  console.log(`=== SUCCESS: Created ${labelsCreated} labels ===`);
                } else {
                  console.log("No labels were created - check feature properties and geometry");
                }
              }

              // Simple centroid calculation fallback
              function getSimpleCentroid(coordinates) {
                let sumLat = 0, sumLng = 0, count = 0;
                coordinates.forEach(coord => {
                  sumLng += coord[0];
                  sumLat += coord[1];
                  count++;
                });
                return { lat: sumLat / count, lng: sumLng / count };
              }

              // Helper: centroid of polygon ring
              function getPolygonCentroid(coords) {
                let area = 0, x = 0, y = 0;
                for (let i = 0, len = coords.length, j = len - 1; i < len; j = i++) {
                  const xi = coords[i][0], yi = coords[i][1];
                  const xj = coords[j][0], yj = coords[j][1];
                  const f = xi * yj - xj * yi;
                  area += f;
                  x += (xi + xj) * f;
                  y += (yi + yj) * f;
                }
                area *= 0.5;
                if (area === 0) return { lat: coords[0][1], lng: coords[0][0] };
                x /= (6 * area);
                y /= (6 * area);
                return { lat: y, lng: x };
              }
            }

            // Helper function to show/hide label layer based on zoom
            function updateWMSLabelVisibility() {
              if (!window._wmsLabelLayer || !window._wmsLabelLayerKey) return;
              // Use the new label zoom levels
              const minZoom = wmsLayerLabelZoomLevels[window._wmsLabelLayerKey];
              if (typeof minZoom === "undefined") {
                // If not defined, always show
                if (!map.hasLayer(window._wmsLabelLayer)) map.addLayer(window._wmsLabelLayer);
                return;
              }
              if (map.getZoom() >= minZoom) {
                if (!map.hasLayer(window._wmsLabelLayer)) map.addLayer(window._wmsLabelLayer);
              } else {
                if (map.hasLayer(window._wmsLabelLayer)) map.removeLayer(window._wmsLabelLayer);
              }
            }
          </script>







          <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
          <script>
            let routingControl = null;
            let routingActive = false;
            let routingMarkers = [];
            let routingLine = null;
            let mapClickHandler = null;

            // Initialize routing functionality after the main map is ready
            function initializeRouting() {
              console.log("Initializing routing functionality...");
              const routingBtn = document.getElementById('routingBtn');
              if (routingBtn && map) {
                console.log("Routing button and map found, setting up click handler");
                routingBtn.onclick = function () {
                  console.log("Routing button clicked, routingActive:", routingActive);
                  if (!routingActive) {
                    // Create a routing interface with real road routing
                    createRoadRoutingInterface();
                    routingActive = true;
                    routingBtn.classList.add('active');
                    console.log("Road routing interface created");
                  } else {
                    // Remove routing interface
                    removeRoadRoutingInterface();
                    routingActive = false;
                    routingBtn.classList.remove('active');
                    console.log("Road routing interface removed");
                  }
                };
                console.log("Routing click handler set up successfully");
              } else {
                console.warn("Routing button or map not found:", { routingBtn: !!routingBtn, map: !!map });
              }
            }

            function createRoadRoutingInterface() {
              // Create routing control panel
              const routingPanel = L.control({ position: 'topright' });
              routingPanel.onAdd = function () {
                const div = L.DomUtil.create('div', 'routing-panel');
                div.innerHTML = `
        <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); min-width: 320px; border: 2px solid #c19a6b;">
          <h4 style="margin: 0 0 15px 0; color: #2e1a0e; font-family: Georgia, serif;">üõ£Ô∏è Road Route Planning</h4>
          <div style="margin-bottom: 12px; position: relative;">
            <label style="display: block; margin-bottom: 6px; font-weight: bold; color: #2e1a0e;">üìç Start Point:</label>
            <input type="text" id="startPoint" placeholder="Enter start location (e.g., Mumbai, India)" style="width: 100%; padding: 8px; border: 1px solid #c19a6b; border-radius: 4px; font-family: Georgia, serif;">
            <div id="startSuggestions" class="search-suggestions"></div>
          </div>
          <div style="margin-bottom: 15px; position: relative;">
            <label style="display: block; margin-bottom: 6px; font-weight: bold; color: #2e1a0e;">üéØ End Point:</label>
            <input type="text" id="endPoint" placeholder="Enter end location (e.g., Delhi, India)" style="width: 100%; padding: 8px; border: 1px solid #c19a6b; border-radius: 4px; font-family: Georgia, serif;">
            <div id="endSuggestions" class="search-suggestions"></div>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 6px; font-weight: bold; color: #2e1a0e;">üöó Transport Mode:</label>
            <select id="transportMode" style="width: 100%; padding: 8px; border: 1px solid #c19a6b; border-radius: 4px; font-family: Georgia, serif;">
              <option value="driving">üöó Driving</option>
              <option value="walking">üö∂ Walking</option>
              <option value="cycling">üö¥ Cycling</option>
            </select>
          </div>
          <div style="display: flex; gap: 8px; margin-bottom: 10px;">
            <button id="calculateRoute" style="background: #c19a6b; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; flex: 1; font-family: Georgia, serif; font-weight: bold;">Ô∏è Get Route</button>
            <button id="clearRoute" style="background: #8a6c4a; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; flex: 1; font-family: Georgia, serif;">üóëÔ∏è Clear Route</button>
          </div>
          <div id="routeInfo" style="margin-top: 12px; font-size: 13px; color: #2e1a0e; background: #fdf6e3; padding: 10px; border-radius: 4px; border-left: 4px solid #c19a6b;"></div>
        </div>
      `;

                // Add event listeners
                setTimeout(() => {
                  const calculateBtn = document.getElementById('calculateRoute');
                  const clearBtn = document.getElementById('clearRoute');
                  const startInput = document.getElementById('startPoint');
                  const endInput = document.getElementById('endPoint');

                  if (calculateBtn) calculateBtn.onclick = calculateRoadRoute;
                  if (clearBtn) clearBtn.onclick = clearRoadRoute;

                  // Add enter key support
                  if (startInput) {
                    startInput.addEventListener('keypress', function (e) {
                      if (e.key === 'Enter') {
                        endInput.focus();
                      }
                    });
                  }

                  if (endInput) {
                    endInput.addEventListener('keypress', function (e) {
                      if (e.key === 'Enter') {
                        calculateRoadRoute();
                      }
                    });
                  }
                  // Initialize autocomplete for routing fields
                  if (startInput && document.getElementById('startSuggestions')) {
                    initializeRoutingAutocomplete('startPoint', 'startSuggestions', coords => {
                      selectedStartCoords = coords;
                    });
                  }
                  if (endInput && document.getElementById('endSuggestions')) {
                    initializeRoutingAutocomplete('endPoint', 'endSuggestions', coords => {
                      selectedEndCoords = coords;
                    });
                  }
                }, 100);

                return div;
              };
              routingPanel.addTo(map);
              window.routingPanel = routingPanel;

              // Add map click handler to hide the panel
              mapClickHandler = function (e) {
                // Check if click is on the routing panel
                const routingPanelElement = document.querySelector('.routing-panel');
                if (routingPanelElement && !routingPanelElement.contains(e.originalEvent.target)) {
                  // Click is outside the panel, hide it
                  removeRoadRoutingInterface();
                  routingActive = false;
                  const routingBtn = document.getElementById('routingBtn');
                  if (routingBtn) {
                    routingBtn.classList.remove('active');
                  }
                }
              };

              // Add the click handler to the map
              map.on('click', mapClickHandler);
            }

            function removeRoadRoutingInterface() {
              if (window.routingPanel) {
                map.removeControl(window.routingPanel);
                window.routingPanel = null;
              }

              // Remove the map click handler
              if (mapClickHandler) {
                map.off('click', mapClickHandler);
                mapClickHandler = null;
              }

            }


            // Add this function after the existing toggleDropdown function
            function closeAdvancedToolsDropdown() {
              const dropdown = document.getElementById('advancedTools-dropdown');
              if (dropdown) {
                dropdown.classList.remove('show');
              }
            }

            // Add event listeners to all buttons in the advanced tools dropdown
            document.addEventListener('DOMContentLoaded', function () {
              const advancedToolsDropdown = document.getElementById('advancedTools-dropdown');
              if (advancedToolsDropdown) {
                // Get all buttons within the advanced tools dropdown
                const buttons = advancedToolsDropdown.querySelectorAll('.sub-btn');

                // Add click event listener to each button
                buttons.forEach(button => {
                  button.addEventListener('click', function () {
                    // Close the dropdown after a short delay to allow the button's onclick function to execute
                    setTimeout(() => {
                      closeAdvancedToolsDropdown();
                    }, 100);
                  });
                });
              }
            });


            // Add this function for utility tools as well
            function closeUtilityToolsDropdown() {
              const dropdown = document.getElementById('utilityTools-dropdown');
              if (dropdown) {
                dropdown.classList.remove('show');
              }
            }

            // Add event listeners to all buttons in the utility tools dropdown
            document.addEventListener('DOMContentLoaded', function () {
              const utilityToolsDropdown = document.getElementById('utilityTools-dropdown');
              if (utilityToolsDropdown) {
                // Get all buttons within the utility tools dropdown
                const buttons = utilityToolsDropdown.querySelectorAll('.sub-btn');

                // Add click event listener to each button
                buttons.forEach(button => {
                  button.addEventListener('click', function () {
                    // Close the dropdown after a short delay to allow the button's onclick function to execute
                    setTimeout(() => {
                      closeUtilityToolsDropdown();
                    }, 100);
                  });
                });
              }
            });



            function calculateRoadRoute() {
              const startPoint = document.getElementById('startPoint').value.trim();
              const endPoint = document.getElementById('endPoint').value.trim();
              const transportMode = document.getElementById('transportMode').value;
              const routeInfo = document.getElementById('routeInfo');
              if (!startPoint || !endPoint) {
                alert('Please enter both start and end points');
                return;
              }
              routeInfo.innerHTML = '<div style="text-align: center;">üîç Searching for locations and calculating route...</div>';

              // Use selected coords if available, else geocode
              const startPromise = fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(startPoint)}&limit=1&addressdetails=1`).then(r => r.json());
              const endPromise = fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(endPoint)}&limit=1&addressdetails=1`).then(r => r.json());

              Promise.all([startPromise, endPromise])
                .then(([startResults, endResults]) => {
                  if (startResults.length === 0 || endResults.length === 0) {
                    routeInfo.innerHTML = '<div style="color: #e74c3c;">‚ùå Could not find one or both locations. Please try different search terms.</div>';
                    return;
                  }

                  const start = startResults[0];
                  const end = endResults[0];
                  if (!start || !start.lat || !start.lon || !end || !end.lat || !end.lon) {
                    routeInfo.innerHTML = '<div style="color: #e74c3c;">‚ùå Invalid location data received. Please try again.</div>';
                    return;
                  }

                  // Clear previous route
                  clearRoadRoute();

                  // Add markers
                  const startMarker = L.marker([start.lat, start.lon], {
                    icon: L.divIcon({
                      className: 'custom-marker start-marker',
                      html: '<div style="background: #27ae60; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">A</div>',
                      iconSize: [30, 30],
                      iconAnchor: [15, 15]
                    })
                  }).addTo(map).bindPopup(`<b>Start:</b> ${start.display_name}`);

                  const endMarker = L.marker([end.lat, end.lon], {
                    icon: L.divIcon({
                      className: 'custom-marker end-marker',
                      html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">B</div>',
                      iconSize: [30, 30],
                      iconAnchor: [15, 15]
                    })
                  }).addTo(map).bindPopup(`<b>End:</b> ${end.display_name}`);

                  routingMarkers.push(startMarker, endMarker);

                  // Now get the actual road route using OSRM
                  const profile = transportMode === 'driving' ? 'driving' : transportMode === 'walking' ? 'foot' : 'cycling';
                  const routeUrl = `https://router.project-osrm.org/route/v1/${profile}/${start.lon},${start.lat};${end.lon},${end.lat}?overview=full&geometries=geojson&steps=true`;

                  return fetch(routeUrl)
                    .then(response => response.json())
                    .then(data => {
                      if (data.routes && data.routes.length > 0) {
                        const route = data.routes[0];

                        // Draw the actual road route
                        routingLine = L.geoJSON(route.geometry, {
                          style: {
                            color: '#3498db',
                            weight: 4,
                            opacity: 0.8
                          }
                        }).addTo(map);

                        // Calculate route statistics
                        const distanceKm = (route.distance / 1000).toFixed(2);
                        const durationMinutes = Math.round(route.duration / 60);
                        const durationHours = Math.floor(durationMinutes / 60);
                        const remainingMinutes = durationMinutes % 60;

                        let durationText = '';
                        if (durationHours > 0) {
                          durationText = `${durationHours}h ${remainingMinutes}m`;
                        } else {
                          durationText = `${durationMinutes}m`;
                        }

                        // Update route info with detailed information
                        routeInfo.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px; color: #2e1a0e;">üõ£Ô∏è Road Route Information:</div>
                <div style="margin-bottom: 5px;"><strong>Distance:</strong> ${distanceKm} km</div>
                <div style="margin-bottom: 5px;"><strong>Duration:</strong> ${durationText}</div>
                <div style="margin-bottom: 5px;"><strong>Mode:</strong> ${transportMode.charAt(0).toUpperCase() + transportMode.slice(1)}</div>
                <div style="margin-bottom: 5px;"><strong>Start:</strong> ${start.display_name}</div>
                <div style="margin-bottom: 5px;"><strong>End:</strong> ${end.display_name}</div>
                <div style="font-size: 11px; color: #7f8c8d; margin-top: 8px;">‚úÖ This shows the actual road route using OpenStreetMap data.</div>
              `;

                        // Fit map to show the entire route
                        const bounds = routingLine.getBounds();
                        map.fitBounds(bounds, { padding: [20, 20] });

                      } else {
                        routeInfo.innerHTML = '<div style="color: #e74c3c;">‚ùå No route found between these locations.</div>';
                      }
                    })
                    .catch(error => {
                      console.error('Error getting route:', error);
                      routeInfo.innerHTML = '<div style="color: #e74c3c;">‚ùå Error calculating route. Please try again.</div>';
                    });
                })
                .catch(error => {
                  console.error('Error geocoding addresses:', error);
                  routeInfo.innerHTML = '<div style="color: #e74c3c;">‚ùå Error finding locations. Please check your internet connection and try again.</div>';
                });
            }

            function clearRoadRoute() {
              // Remove markers
              routingMarkers.forEach(marker => map.removeLayer(marker));
              routingMarkers = [];

              // Remove route line
              if (routingLine) {
                map.removeLayer(routingLine);
                routingLine = null;
              }

              // Clear route info
              const routeInfo = document.getElementById('routeInfo');
              if (routeInfo) {
                routeInfo.innerHTML = '';
              }
            }

            // Wait for the main map to be initialized
            document.addEventListener('DOMContentLoaded', function () {
              console.log("DOM loaded, checking for map...");
              // Wait longer for the map to be initialized since it has a 100ms delay
              setTimeout(function () {
                if (map) {
                  console.log("Map found, initializing routing");
                  initializeRouting();
                } else {
                  console.log("Map not found, waiting...");
                  // Wait for map to be initialized with a longer interval
                  const checkMapInterval = setInterval(function () {
                    if (map) {
                      clearInterval(checkMapInterval);
                      console.log("Map found after waiting, initializing routing");
                      initializeRouting();
                    }
                  }, 200);

                  // Stop checking after 10 seconds to avoid infinite loop
                  setTimeout(function () {
                    clearInterval(checkMapInterval);
                    console.error("Map not found after 10 seconds, routing initialization failed");
                  }, 10000);
                }
              }, 200); // Wait 200ms to ensure map initialization is complete
            });







          </script>

          <!-- Enhanced search functionality with autocomplete -->
          <script>
            let searchTimeout;
            let currentSearchResults = [];

            // Initialize search functionality
            function initializeSearch() {
              const searchInput = document.getElementById('searchInput');
              const suggestionsContainer = document.getElementById('searchSuggestions');

              // Add event listeners for autocomplete
              searchInput.addEventListener('input', function () {
                const query = this.value.trim();

                // Clear previous timeout
                if (searchTimeout) {
                  clearTimeout(searchTimeout);
                }

                // Hide suggestions if query is empty
                if (query.length < 2) {
                  hideSuggestions();
                  return;
                }

                // Debounce the search to avoid too many API calls
                searchTimeout = setTimeout(() => {
                  performAutocompleteSearch(query);
                }, 300);
              });

              // Handle keyboard navigation
              searchInput.addEventListener('keydown', function (e) {
                const suggestions = suggestionsContainer.querySelectorAll('.suggestion-item');
                const activeSuggestion = suggestionsContainer.querySelector('.suggestion-item.active');

                switch (e.key) {
                  case 'ArrowDown':
                    e.preventDefault();
                    navigateSuggestions('down', suggestions, activeSuggestion);
                    break;
                  case 'ArrowUp':
                    e.preventDefault();
                    navigateSuggestions('up', suggestions, activeSuggestion);
                    break;
                  case 'Enter':
                    e.preventDefault();
                    if (activeSuggestion) {
                      selectSuggestion(activeSuggestion);
                    } else {
                      performSearch();
                    }
                    break;
                  case 'Escape':
                    hideSuggestions();
                    break;
                }
              });

              // Handle clicks outside to close suggestions
              document.addEventListener('click', function (e) {
                if (!searchInput.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                  hideSuggestions();
                }
              });
            }

            // Perform autocomplete search
            function performAutocompleteSearch(query) {
              // Use multiple geocoding services for better results
              Promise.all([
                searchNominatim(query),
                searchPhoton(query)
              ]).then(results => {
                const allResults = [...results[0], ...results[1]];
                const uniqueResults = removeDuplicates(allResults);
                currentSearchResults = uniqueResults.slice(0, 8); // Limit to 8 results
                showSuggestions(currentSearchResults);
              }).catch(error => {
                console.error('Autocomplete search error:', error);
                // Fallback to Nominatim only
                searchNominatim(query).then(results => {
                  currentSearchResults = results.slice(0, 8);
                  showSuggestions(currentSearchResults);
                });
              });
            }

            // Search using Nominatim (OpenStreetMap)
            function searchNominatim(query) {
              return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`)
                .then(response => response.json())
                .then(data => data.map(item => ({
                  name: item.display_name,
                  lat: parseFloat(item.lat),
                  lon: parseFloat(item.lon),
                  type: item.type || 'place',
                  details: item.address?.city || item.address?.town || item.address?.village || '',
                  source: 'nominatim'
                })));
            }

            // Search using Photon (Komoot)
            function searchPhoton(query) {
              return fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=5`)
                .then(response => response.json())
                .then(data => data.features.map(feature => ({
                  name: feature.properties.name || feature.properties.display_name,
                  lat: feature.geometry.coordinates[1],
                  lon: feature.geometry.coordinates[0],
                  type: feature.properties.type || 'place',
                  details: feature.properties.city || feature.properties.town || feature.properties.village || '',
                  source: 'photon'
                })));
            }

            // Remove duplicate results
            function removeDuplicates(results) {
              const seen = new Set();
              return results.filter(result => {
                const key = `${result.lat},${result.lon}`;
                if (seen.has(key)) {
                  return false;
                }
                seen.add(key);
                return true;
              });
            }

            // Show suggestions dropdown
            function showSuggestions(results) {
              const suggestionsContainer = document.getElementById('searchSuggestions');
              const searchInput = document.getElementById('searchInput');

              if (results.length === 0) {
                suggestionsContainer.innerHTML = '<div class="suggestion-item">No results found</div>';
              } else {
                suggestionsContainer.innerHTML = results.map(result => `
            <div class="suggestion-item" data-lat="${result.lat}" data-lon="${result.lon}" data-name="${result.name}">
              <div class="suggestion-name">${result.name}</div>
              <div class="suggestion-details">
                ${result.details ? result.details + ' ‚Ä¢ ' : ''}
                <span class="suggestion-type">${result.type}</span>
              </div>
            </div>
          `).join('');
              }

              // Add click event listeners to suggestions
              suggestionsContainer.querySelectorAll('.suggestion-item').forEach(item => {
                if (item.textContent !== 'No results found') {
                  item.addEventListener('click', () => selectSuggestion(item));
                }
              });

              // Adaptive positioning - check if there's enough space below
              const inputRect = searchInput.getBoundingClientRect();
              const viewportHeight = window.innerHeight;
              const spaceBelow = viewportHeight - inputRect.bottom;
              const suggestionsHeight = Math.min(200, results.length * 40); // Approximate height

              // Remove any existing positioning classes
              suggestionsContainer.classList.remove('above');

              // If not enough space below, position above
              if (spaceBelow < suggestionsHeight && inputRect.top > suggestionsHeight) {
                suggestionsContainer.classList.add('above');
              }

              suggestionsContainer.classList.add('show');
            }

            // Hide suggestions dropdown
            function hideSuggestions() {
              const suggestionsContainer = document.getElementById('searchSuggestions');
              suggestionsContainer.classList.remove('show');
            }

            // Navigate suggestions with keyboard
            function navigateSuggestions(direction, suggestions, activeSuggestion) {
              if (suggestions.length === 0) return;

              let nextIndex = 0;

              if (activeSuggestion) {
                const currentIndex = Array.from(suggestions).indexOf(activeSuggestion);
                if (direction === 'down') {
                  nextIndex = (currentIndex + 1) % suggestions.length;
                } else {
                  nextIndex = currentIndex === 0 ? suggestions.length - 1 : currentIndex - 1;
                }
                activeSuggestion.classList.remove('active');
              }

              suggestions[nextIndex].classList.add('active');
              suggestions[nextIndex].scrollIntoView({ block: 'nearest' });
            }

            // Select a suggestion
            function selectSuggestion(suggestionItem) {
              const lat = parseFloat(suggestionItem.dataset.lat);
              const lon = parseFloat(suggestionItem.dataset.lon);
              const name = suggestionItem.dataset.name;

              // Update search input
              document.getElementById('searchInput').value = name;

              // Hide suggestions
              hideSuggestions();

              // Navigate to location
              navigateToLocation(lat, lon, name);
            }

            // Navigate to a specific location
            function navigateToLocation(lat, lon, name) {
              // Remove existing search markers
              map.eachLayer(layer => {
                if (layer._searchMarker) {
                  map.removeLayer(layer);
                }
              });

              // Add new marker
              const marker = L.marker([lat, lon])
                .addTo(map)
                .bindPopup(`<b>${name}</b><br>Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}`)
                .openPopup();

              // Mark as search marker for easy removal
              marker._searchMarker = true;

              // Zoom to location
              map.setView([lat, lon], 15);
            }

            // Enhanced performSearch function (for button click)
            function performSearch() {
              const query = document.getElementById("searchInput").value.trim();
              if (!query) return;

              // If we have current search results, use the first one
              if (currentSearchResults.length > 0) {
                const firstResult = currentSearchResults[0];
                navigateToLocation(firstResult.lat, firstResult.lon, firstResult.name);
                return;
              }

              // Otherwise, perform a new search
              performAutocompleteSearch(query);
            }
          </script>

          <script>
            let selectedStartCoords = null;
            let selectedEndCoords = null;

            function initializeRoutingAutocomplete(inputId, suggestionsId, onSelect) {
              const input = document.getElementById(inputId);
              const suggestions = document.getElementById(suggestionsId);
              let timeout, results = [];

              input.addEventListener('input', function () {
                const query = this.value.trim();
                if (timeout) clearTimeout(timeout);
                if (query.length < 2) {
                  suggestions.classList.remove('show');
                  return;
                }
                timeout = setTimeout(() => {
                  Promise.all([searchNominatim(query), searchPhoton(query)]).then(res => {
                    results = [...res[0], ...res[1]];
                    results = removeDuplicates(results).slice(0, 8);
                    if (results.length === 0) {
                      suggestions.innerHTML = '<div class="suggestion-item">No results found</div>';
                    } else {
                      suggestions.innerHTML = results.map(r => `
                  <div class="suggestion-item" data-lat="${r.lat}" data-lon="${r.lon}" data-name="${r.name}">
                    <div class="suggestion-name">${r.name}</div>
                    <div class="suggestion-details">
                      ${r.details ? r.details + ' ‚Ä¢ ' : ''}
                      <span class="suggestion-type">${r.type}</span>
                    </div>
                  </div>
                `).join('');
                    }
                    suggestions.classList.add('show');
                    // Adaptive positioning
                    const inputRect = input.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    const spaceBelow = viewportHeight - inputRect.bottom;
                    const suggestionsHeight = Math.min(200, results.length * 40);
                    suggestions.classList.remove('above');
                    if (spaceBelow < suggestionsHeight && inputRect.top > suggestionsHeight) {
                      suggestions.classList.add('above');
                    }
                    // Click handler
                    suggestions.querySelectorAll('.suggestion-item').forEach(item => {
                      if (item.textContent !== 'No results found') {
                        item.addEventListener('click', () => {
                          input.value = item.dataset.name;
                          suggestions.classList.remove('show');
                          onSelect({ lat: parseFloat(item.dataset.lat), lon: parseFloat(item.dataset.lon), name: item.dataset.name });
                        });
                      }
                    });
                  });
                }, 300);
              });

              // Keyboard navigation (optional, similar to main search)
              input.addEventListener('keydown', function (e) {
                const items = suggestions.querySelectorAll('.suggestion-item');
                const active = suggestions.querySelector('.suggestion-item.active');
                let idx = Array.from(items).indexOf(active);
                if (e.key === 'ArrowDown') {
                  e.preventDefault();
                  if (active) active.classList.remove('active');
                  idx = (idx + 1) % items.length;
                  items[idx].classList.add('active');
                  items[idx].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                  e.preventDefault();
                  if (active) active.classList.remove('active');
                  idx = idx <= 0 ? items.length - 1 : idx - 1;
                  items[idx].classList.add('active');
                  items[idx].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter') {
                  e.preventDefault();
                  if (active) {
                    active.click();
                  }
                } else if (e.key === 'Escape') {
                  suggestions.classList.remove('show');
                }
              });

              // Hide on outside click
              document.addEventListener('click', function (e) {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                  suggestions.classList.remove('show');
                }
              });
            }
          </script>

          <script>
            initializeRoutingAutocomplete('startPoint', 'startSuggestions', coords => {
              selectedStartCoords = coords;
            });
            initializeRoutingAutocomplete('endPoint', 'endSuggestions', coords => {
              selectedEndCoords = coords;
            });
          </script>

          <div class="buffer-table-container" id="bufferTablePanel" style="display:none;">
            <div class="buffer-table-filter">
              <label for="bufferTableSearch"><b>üîç Filter:</b></label>
              <input type="text" id="bufferTableSearch" placeholder="Type to filter rows...">
            </div>
            <div class="buffer-table-scroll">
              <table class="buffer-table" id="bufferTable">
                <thead>
                  <tr>
                    <th>OBJECTID</th>
                    <th>District Name</th>
                    <th>Taluka Name</th>
                    <th>Village Name</th>
                    <th>Latitude</th>
                    <th>Longitude</th>
                    <th>Use of Well</th>
                    <th>Measurement Point</th>
                    <th>Curbing Height</th>
                    <th>Water Level from Ground</th>
                    <th>Diameter of Well</th>
                    <th>Well Status</th>
                    <th>Unique ID</th>
                    <th>Total Meter</th>
                  </tr>
                </thead>
                <tbody>
                  <!-- JS will inject rows here -->
                </tbody>
              </table>
            </div>
          </div>
          <!-- Elevation Profile Panel -->
          <!-- Elevation Profile Panel -->
          <div id="elevation-profile-panel"
            style="display:none; position: absolute; bottom: 20px; left: 20px; width: 600px; z-index: 9999;">
            <div id="elevation-summary"
              style="font-family: 'Roboto', monospace; background: rgba(0,0,0,0.5); color: #fff; padding: 8px 16px 8px 16px; border-radius: 6px 6px 0 0; font-size: 16px; display: flex; justify-content: space-between; align-items: center; position: relative; min-height: 40px;">
              <div id="elevation-summary-content" style="flex: 1; margin-right: 40px;">
                <!-- Summary stats will go here -->
              </div>
              <button class="close-btn"
                style="position: absolute; top: 50%; right: 12px; transform: translateY(-50%); background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; color: white; font-size: 18px; cursor: pointer; font-weight: bold; line-height: 1; z-index: 10000; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;">&times;</button>
            </div>
            <div id="elevation-chart"
              style="width: 100%; height: 250px; background: linear-gradient(180deg, #fff 0%, #f7f7f7 100%); border-radius: 0 0 6px 6px;">
            </div>
          </div>

</body>

</html>